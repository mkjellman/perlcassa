#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Cassandra::ConsistencyLevel;
use constant ONE => 1;
use constant QUORUM => 2;
use constant LOCAL_QUORUM => 3;
use constant EACH_QUORUM => 4;
use constant ALL => 5;
use constant ANY => 6;
use constant TWO => 7;
use constant THREE => 8;
package Cassandra::IndexOperator;
use constant EQ => 0;
use constant GTE => 1;
use constant GT => 2;
use constant LTE => 3;
use constant LT => 4;
package Cassandra::IndexType;
use constant KEYS => 0;
use constant CUSTOM => 1;
package Cassandra::Compression;
use constant GZIP => 1;
use constant NONE => 2;
package Cassandra::CqlResultType;
use constant ROWS => 1;
use constant VOID => 2;
use constant INT => 3;
package Cassandra::Column;
use base qw(Class::Accessor);
Cassandra::Column->mk_accessors( qw( name value timestamp ttl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  $self->{timestamp} = undef;
  $self->{ttl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{ttl}) {
      $self->{ttl} = $vals->{ttl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{ttl});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ttl}) {
    $xfer += $output->writeFieldBegin('ttl', TType::I32, 4);
    $xfer += $output->writeI32($self->{ttl});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SuperColumn;
use base qw(Class::Accessor);
Cassandra::SuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columns} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Cassandra::Column();
            $xfer += $elem5->read($input);
            push(@{$self->{columns}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter6 (@{$self->{columns}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CounterColumn;
use base qw(Class::Accessor);
Cassandra::CounterColumn->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CounterColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CounterColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::I64, 2);
    $xfer += $output->writeI64($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CounterSuperColumn;
use base qw(Class::Accessor);
Cassandra::CounterSuperColumn->mk_accessors( qw( name columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CounterSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{columns} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new Cassandra::CounterColumn();
            $xfer += $elem12->read($input);
            push(@{$self->{columns}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CounterSuperColumn');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter13 (@{$self->{columns}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnOrSuperColumn;
use base qw(Class::Accessor);
Cassandra::ColumnOrSuperColumn->mk_accessors( qw( column super_column counter_column counter_super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column} = undef;
  $self->{super_column} = undef;
  $self->{counter_column} = undef;
  $self->{counter_super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{counter_column}) {
      $self->{counter_column} = $vals->{counter_column};
    }
    if (defined $vals->{counter_super_column}) {
      $self->{counter_super_column} = $vals->{counter_super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnOrSuperColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::Column();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{super_column} = new Cassandra::SuperColumn();
        $xfer += $self->{super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{counter_column} = new Cassandra::CounterColumn();
        $xfer += $self->{counter_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{counter_super_column} = new Cassandra::CounterSuperColumn();
        $xfer += $self->{counter_super_column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnOrSuperColumn');
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 1);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRUCT, 2);
    $xfer += $self->{super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter_column}) {
    $xfer += $output->writeFieldBegin('counter_column', TType::STRUCT, 3);
    $xfer += $self->{counter_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{counter_super_column}) {
    $xfer += $output->writeFieldBegin('counter_super_column', TType::STRUCT, 4);
    $xfer += $self->{counter_super_column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::NotFoundException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'NotFoundException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NotFoundException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::InvalidRequestException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::InvalidRequestException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidRequestException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidRequestException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::UnavailableException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'UnavailableException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnavailableException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TimedOutException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'TimedOutException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TimedOutException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthenticationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthorizationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Cassandra::AuthorizationException->mk_accessors( qw( why ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{why} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{why}) {
      $self->{why} = $vals->{why};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthorizationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{why});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthorizationException');
  if (defined $self->{why}) {
    $xfer += $output->writeFieldBegin('why', TType::STRING, 1);
    $xfer += $output->writeString($self->{why});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SchemaDisagreementException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'SchemaDisagreementException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SchemaDisagreementException');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnParent;
use base qw(Class::Accessor);
Cassandra::ColumnParent->mk_accessors( qw( column_family super_column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnParent';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnParent');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnPath;
use base qw(Class::Accessor);
Cassandra::ColumnPath->mk_accessors( qw( column_family super_column column ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{super_column} = undef;
  $self->{column} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnPath';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnPath');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 4);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 5);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SliceRange;
use base qw(Class::Accessor);
Cassandra::SliceRange->mk_accessors( qw( start finish reversed count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start} = undef;
  $self->{finish} = undef;
  $self->{reversed} = 0;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{finish}) {
      $self->{finish} = $vals->{finish};
    }
    if (defined $vals->{reversed}) {
      $self->{reversed} = $vals->{reversed};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SliceRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{finish});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{reversed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SliceRange');
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::STRING, 1);
    $xfer += $output->writeString($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{finish}) {
    $xfer += $output->writeFieldBegin('finish', TType::STRING, 2);
    $xfer += $output->writeString($self->{finish});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{reversed}) {
    $xfer += $output->writeFieldBegin('reversed', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{reversed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 4);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::SlicePredicate;
use base qw(Class::Accessor);
Cassandra::SlicePredicate->mk_accessors( qw( column_names slice_range ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_names} = undef;
  $self->{slice_range} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_names}) {
      $self->{column_names} = $vals->{column_names};
    }
    if (defined $vals->{slice_range}) {
      $self->{slice_range} = $vals->{slice_range};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SlicePredicate';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{column_names} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $xfer += $input->readString(\$elem19);
            push(@{$self->{column_names}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{slice_range} = new Cassandra::SliceRange();
        $xfer += $self->{slice_range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SlicePredicate');
  if (defined $self->{column_names}) {
    $xfer += $output->writeFieldBegin('column_names', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{column_names}}));
      {
        foreach my $iter20 (@{$self->{column_names}}) 
        {
          $xfer += $output->writeString($iter20);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{slice_range}) {
    $xfer += $output->writeFieldBegin('slice_range', TType::STRUCT, 2);
    $xfer += $self->{slice_range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::IndexExpression;
use base qw(Class::Accessor);
Cassandra::IndexExpression->mk_accessors( qw( column_name op value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_name} = undef;
  $self->{op} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_name}) {
      $self->{column_name} = $vals->{column_name};
    }
    if (defined $vals->{op}) {
      $self->{op} = $vals->{op};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexExpression';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{op});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexExpression');
  if (defined $self->{column_name}) {
    $xfer += $output->writeFieldBegin('column_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{op}) {
    $xfer += $output->writeFieldBegin('op', TType::I32, 2);
    $xfer += $output->writeI32($self->{op});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::IndexClause;
use base qw(Class::Accessor);
Cassandra::IndexClause->mk_accessors( qw( expressions start_key count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{expressions} = undef;
  $self->{start_key} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{expressions}) {
      $self->{expressions} = $vals->{expressions};
    }
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexClause';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size21 = 0;
          $self->{expressions} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = new Cassandra::IndexExpression();
            $xfer += $elem26->read($input);
            push(@{$self->{expressions}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexClause');
  if (defined $self->{expressions}) {
    $xfer += $output->writeFieldBegin('expressions', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{expressions}}));
      {
        foreach my $iter27 (@{$self->{expressions}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', TType::STRING, 2);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 3);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyRange;
use base qw(Class::Accessor);
Cassandra::KeyRange->mk_accessors( qw( start_key end_key start_token end_token row_filter count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_key} = undef;
  $self->{end_key} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{row_filter} = undef;
  $self->{count} = 100;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_key}) {
      $self->{start_key} = $vals->{start_key};
    }
    if (defined $vals->{end_key}) {
      $self->{end_key} = $vals->{end_key};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{row_filter}) {
      $self->{row_filter} = $vals->{row_filter};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{row_filter} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $elem33 = new Cassandra::IndexExpression();
            $xfer += $elem33->read($input);
            push(@{$self->{row_filter}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyRange');
  if (defined $self->{start_key}) {
    $xfer += $output->writeFieldBegin('start_key', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_key}) {
    $xfer += $output->writeFieldBegin('end_key', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 3);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 4);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 5);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_filter}) {
    $xfer += $output->writeFieldBegin('row_filter', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{row_filter}}));
      {
        foreach my $iter34 (@{$self->{row_filter}}) 
        {
          $xfer += ${iter34}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeySlice;
use base qw(Class::Accessor);
Cassandra::KeySlice->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeySlice';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size35 = 0;
          $self->{columns} = [];
          my $_etype38 = 0;
          $xfer += $input->readListBegin(\$_etype38, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $elem40 = undef;
            $elem40 = new Cassandra::ColumnOrSuperColumn();
            $xfer += $elem40->read($input);
            push(@{$self->{columns}},$elem40);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeySlice');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter41 (@{$self->{columns}}) 
        {
          $xfer += ${iter41}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KeyCount;
use base qw(Class::Accessor);
Cassandra::KeyCount->mk_accessors( qw( key count ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{count} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KeyCount';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KeyCount');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 2);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Deletion;
use base qw(Class::Accessor);
Cassandra::Deletion->mk_accessors( qw( timestamp super_column predicate ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{timestamp} = undef;
  $self->{super_column} = undef;
  $self->{predicate} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{super_column}) {
      $self->{super_column} = $vals->{super_column};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Deletion';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{super_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Deletion');
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 1);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{super_column}) {
    $xfer += $output->writeFieldBegin('super_column', TType::STRING, 2);
    $xfer += $output->writeString($self->{super_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Mutation;
use base qw(Class::Accessor);
Cassandra::Mutation->mk_accessors( qw( column_or_supercolumn deletion ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_or_supercolumn} = undef;
  $self->{deletion} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_or_supercolumn}) {
      $self->{column_or_supercolumn} = $vals->{column_or_supercolumn};
    }
    if (defined $vals->{deletion}) {
      $self->{deletion} = $vals->{deletion};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Mutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_or_supercolumn} = new Cassandra::ColumnOrSuperColumn();
        $xfer += $self->{column_or_supercolumn}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{deletion} = new Cassandra::Deletion();
        $xfer += $self->{deletion}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Mutation');
  if (defined $self->{column_or_supercolumn}) {
    $xfer += $output->writeFieldBegin('column_or_supercolumn', TType::STRUCT, 1);
    $xfer += $self->{column_or_supercolumn}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deletion}) {
    $xfer += $output->writeFieldBegin('deletion', TType::STRUCT, 2);
    $xfer += $self->{deletion}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::EndpointDetails;
use base qw(Class::Accessor);
Cassandra::EndpointDetails->mk_accessors( qw( host datacenter rack ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{host} = undef;
  $self->{datacenter} = undef;
  $self->{rack} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{host}) {
      $self->{host} = $vals->{host};
    }
    if (defined $vals->{datacenter}) {
      $self->{datacenter} = $vals->{datacenter};
    }
    if (defined $vals->{rack}) {
      $self->{rack} = $vals->{rack};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'EndpointDetails';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{host});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{datacenter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rack});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('EndpointDetails');
  if (defined $self->{host}) {
    $xfer += $output->writeFieldBegin('host', TType::STRING, 1);
    $xfer += $output->writeString($self->{host});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{datacenter}) {
    $xfer += $output->writeFieldBegin('datacenter', TType::STRING, 2);
    $xfer += $output->writeString($self->{datacenter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rack}) {
    $xfer += $output->writeFieldBegin('rack', TType::STRING, 3);
    $xfer += $output->writeString($self->{rack});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::TokenRange;
use base qw(Class::Accessor);
Cassandra::TokenRange->mk_accessors( qw( start_token end_token endpoints rpc_endpoints endpoint_details ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{endpoints} = undef;
  $self->{rpc_endpoints} = undef;
  $self->{endpoint_details} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{endpoints}) {
      $self->{endpoints} = $vals->{endpoints};
    }
    if (defined $vals->{rpc_endpoints}) {
      $self->{rpc_endpoints} = $vals->{rpc_endpoints};
    }
    if (defined $vals->{endpoint_details}) {
      $self->{endpoint_details} = $vals->{endpoint_details};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TokenRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size42 = 0;
          $self->{endpoints} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $xfer += $input->readString(\$elem47);
            push(@{$self->{endpoints}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size48 = 0;
          $self->{rpc_endpoints} = [];
          my $_etype51 = 0;
          $xfer += $input->readListBegin(\$_etype51, \$_size48);
          for (my $_i52 = 0; $_i52 < $_size48; ++$_i52)
          {
            my $elem53 = undef;
            $xfer += $input->readString(\$elem53);
            push(@{$self->{rpc_endpoints}},$elem53);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size54 = 0;
          $self->{endpoint_details} = [];
          my $_etype57 = 0;
          $xfer += $input->readListBegin(\$_etype57, \$_size54);
          for (my $_i58 = 0; $_i58 < $_size54; ++$_i58)
          {
            my $elem59 = undef;
            $elem59 = new Cassandra::EndpointDetails();
            $xfer += $elem59->read($input);
            push(@{$self->{endpoint_details}},$elem59);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TokenRange');
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 1);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 2);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endpoints}) {
    $xfer += $output->writeFieldBegin('endpoints', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{endpoints}}));
      {
        foreach my $iter60 (@{$self->{endpoints}}) 
        {
          $xfer += $output->writeString($iter60);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rpc_endpoints}) {
    $xfer += $output->writeFieldBegin('rpc_endpoints', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rpc_endpoints}}));
      {
        foreach my $iter61 (@{$self->{rpc_endpoints}}) 
        {
          $xfer += $output->writeString($iter61);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{endpoint_details}) {
    $xfer += $output->writeFieldBegin('endpoint_details', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{endpoint_details}}));
      {
        foreach my $iter62 (@{$self->{endpoint_details}}) 
        {
          $xfer += ${iter62}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::AuthenticationRequest;
use base qw(Class::Accessor);
Cassandra::AuthenticationRequest->mk_accessors( qw( credentials ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{credentials} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{credentials}) {
      $self->{credentials} = $vals->{credentials};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AuthenticationRequest';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size63 = 0;
          $self->{credentials} = {};
          my $_ktype64 = 0;
          my $_vtype65 = 0;
          $xfer += $input->readMapBegin(\$_ktype64, \$_vtype65, \$_size63);
          for (my $_i67 = 0; $_i67 < $_size63; ++$_i67)
          {
            my $key68 = '';
            my $val69 = '';
            $xfer += $input->readString(\$key68);
            $xfer += $input->readString(\$val69);
            $self->{credentials}->{$key68} = $val69;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AuthenticationRequest');
  if (defined $self->{credentials}) {
    $xfer += $output->writeFieldBegin('credentials', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{credentials}}));
      {
        while( my ($kiter70,$viter71) = each %{$self->{credentials}}) 
        {
          $xfer += $output->writeString($kiter70);
          $xfer += $output->writeString($viter71);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::ColumnDef;
use base qw(Class::Accessor);
Cassandra::ColumnDef->mk_accessors( qw( name validation_class index_type index_name index_options ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{validation_class} = undef;
  $self->{index_type} = undef;
  $self->{index_name} = undef;
  $self->{index_options} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{validation_class}) {
      $self->{validation_class} = $vals->{validation_class};
    }
    if (defined $vals->{index_type}) {
      $self->{index_type} = $vals->{index_type};
    }
    if (defined $vals->{index_name}) {
      $self->{index_name} = $vals->{index_name};
    }
    if (defined $vals->{index_options}) {
      $self->{index_options} = $vals->{index_options};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{index_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{index_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size72 = 0;
          $self->{index_options} = {};
          my $_ktype73 = 0;
          my $_vtype74 = 0;
          $xfer += $input->readMapBegin(\$_ktype73, \$_vtype74, \$_size72);
          for (my $_i76 = 0; $_i76 < $_size72; ++$_i76)
          {
            my $key77 = '';
            my $val78 = '';
            $xfer += $input->readString(\$key77);
            $xfer += $input->readString(\$val78);
            $self->{index_options}->{$key77} = $val78;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{validation_class}) {
    $xfer += $output->writeFieldBegin('validation_class', TType::STRING, 2);
    $xfer += $output->writeString($self->{validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_type}) {
    $xfer += $output->writeFieldBegin('index_type', TType::I32, 3);
    $xfer += $output->writeI32($self->{index_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_name}) {
    $xfer += $output->writeFieldBegin('index_name', TType::STRING, 4);
    $xfer += $output->writeString($self->{index_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_options}) {
    $xfer += $output->writeFieldBegin('index_options', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{index_options}}));
      {
        while( my ($kiter79,$viter80) = each %{$self->{index_options}}) 
        {
          $xfer += $output->writeString($kiter79);
          $xfer += $output->writeString($viter80);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CfDef;
use base qw(Class::Accessor);
Cassandra::CfDef->mk_accessors( qw( keyspace name column_type comparator_type subcomparator_type comment read_repair_chance column_metadata gc_grace_seconds default_validation_class id min_compaction_threshold max_compaction_threshold replicate_on_write key_validation_class key_alias compaction_strategy compaction_strategy_options compression_options bloom_filter_fp_chance caching dclocal_read_repair_chance row_cache_size key_cache_size row_cache_save_period_in_seconds key_cache_save_period_in_seconds memtable_flush_after_mins memtable_throughput_in_mb memtable_operations_in_millions merge_shards_chance row_cache_provider row_cache_keys_to_save ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  $self->{name} = undef;
  $self->{column_type} = "Standard";
  $self->{comparator_type} = "BytesType";
  $self->{subcomparator_type} = undef;
  $self->{comment} = undef;
  $self->{read_repair_chance} = undef;
  $self->{column_metadata} = undef;
  $self->{gc_grace_seconds} = undef;
  $self->{default_validation_class} = undef;
  $self->{id} = undef;
  $self->{min_compaction_threshold} = undef;
  $self->{max_compaction_threshold} = undef;
  $self->{replicate_on_write} = undef;
  $self->{key_validation_class} = undef;
  $self->{key_alias} = undef;
  $self->{compaction_strategy} = undef;
  $self->{compaction_strategy_options} = undef;
  $self->{compression_options} = undef;
  $self->{bloom_filter_fp_chance} = undef;
  $self->{caching} = "keys_only";
  $self->{dclocal_read_repair_chance} = 0;
  $self->{row_cache_size} = undef;
  $self->{key_cache_size} = undef;
  $self->{row_cache_save_period_in_seconds} = undef;
  $self->{key_cache_save_period_in_seconds} = undef;
  $self->{memtable_flush_after_mins} = undef;
  $self->{memtable_throughput_in_mb} = undef;
  $self->{memtable_operations_in_millions} = undef;
  $self->{merge_shards_chance} = undef;
  $self->{row_cache_provider} = undef;
  $self->{row_cache_keys_to_save} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{column_type}) {
      $self->{column_type} = $vals->{column_type};
    }
    if (defined $vals->{comparator_type}) {
      $self->{comparator_type} = $vals->{comparator_type};
    }
    if (defined $vals->{subcomparator_type}) {
      $self->{subcomparator_type} = $vals->{subcomparator_type};
    }
    if (defined $vals->{comment}) {
      $self->{comment} = $vals->{comment};
    }
    if (defined $vals->{read_repair_chance}) {
      $self->{read_repair_chance} = $vals->{read_repair_chance};
    }
    if (defined $vals->{column_metadata}) {
      $self->{column_metadata} = $vals->{column_metadata};
    }
    if (defined $vals->{gc_grace_seconds}) {
      $self->{gc_grace_seconds} = $vals->{gc_grace_seconds};
    }
    if (defined $vals->{default_validation_class}) {
      $self->{default_validation_class} = $vals->{default_validation_class};
    }
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{min_compaction_threshold}) {
      $self->{min_compaction_threshold} = $vals->{min_compaction_threshold};
    }
    if (defined $vals->{max_compaction_threshold}) {
      $self->{max_compaction_threshold} = $vals->{max_compaction_threshold};
    }
    if (defined $vals->{replicate_on_write}) {
      $self->{replicate_on_write} = $vals->{replicate_on_write};
    }
    if (defined $vals->{key_validation_class}) {
      $self->{key_validation_class} = $vals->{key_validation_class};
    }
    if (defined $vals->{key_alias}) {
      $self->{key_alias} = $vals->{key_alias};
    }
    if (defined $vals->{compaction_strategy}) {
      $self->{compaction_strategy} = $vals->{compaction_strategy};
    }
    if (defined $vals->{compaction_strategy_options}) {
      $self->{compaction_strategy_options} = $vals->{compaction_strategy_options};
    }
    if (defined $vals->{compression_options}) {
      $self->{compression_options} = $vals->{compression_options};
    }
    if (defined $vals->{bloom_filter_fp_chance}) {
      $self->{bloom_filter_fp_chance} = $vals->{bloom_filter_fp_chance};
    }
    if (defined $vals->{caching}) {
      $self->{caching} = $vals->{caching};
    }
    if (defined $vals->{dclocal_read_repair_chance}) {
      $self->{dclocal_read_repair_chance} = $vals->{dclocal_read_repair_chance};
    }
    if (defined $vals->{row_cache_size}) {
      $self->{row_cache_size} = $vals->{row_cache_size};
    }
    if (defined $vals->{key_cache_size}) {
      $self->{key_cache_size} = $vals->{key_cache_size};
    }
    if (defined $vals->{row_cache_save_period_in_seconds}) {
      $self->{row_cache_save_period_in_seconds} = $vals->{row_cache_save_period_in_seconds};
    }
    if (defined $vals->{key_cache_save_period_in_seconds}) {
      $self->{key_cache_save_period_in_seconds} = $vals->{key_cache_save_period_in_seconds};
    }
    if (defined $vals->{memtable_flush_after_mins}) {
      $self->{memtable_flush_after_mins} = $vals->{memtable_flush_after_mins};
    }
    if (defined $vals->{memtable_throughput_in_mb}) {
      $self->{memtable_throughput_in_mb} = $vals->{memtable_throughput_in_mb};
    }
    if (defined $vals->{memtable_operations_in_millions}) {
      $self->{memtable_operations_in_millions} = $vals->{memtable_operations_in_millions};
    }
    if (defined $vals->{merge_shards_chance}) {
      $self->{merge_shards_chance} = $vals->{merge_shards_chance};
    }
    if (defined $vals->{row_cache_provider}) {
      $self->{row_cache_provider} = $vals->{row_cache_provider};
    }
    if (defined $vals->{row_cache_keys_to_save}) {
      $self->{row_cache_keys_to_save} = $vals->{row_cache_keys_to_save};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CfDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comparator_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{subcomparator_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comment});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{read_repair_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size81 = 0;
          $self->{column_metadata} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            $elem86 = new Cassandra::ColumnDef();
            $xfer += $elem86->read($input);
            push(@{$self->{column_metadata}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{gc_grace_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{default_validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{min_compaction_threshold});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{max_compaction_threshold});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^24$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{replicate_on_write});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^26$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key_validation_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^28$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key_alias});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^29$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{compaction_strategy});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^30$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size87 = 0;
          $self->{compaction_strategy_options} = {};
          my $_ktype88 = 0;
          my $_vtype89 = 0;
          $xfer += $input->readMapBegin(\$_ktype88, \$_vtype89, \$_size87);
          for (my $_i91 = 0; $_i91 < $_size87; ++$_i91)
          {
            my $key92 = '';
            my $val93 = '';
            $xfer += $input->readString(\$key92);
            $xfer += $input->readString(\$val93);
            $self->{compaction_strategy_options}->{$key92} = $val93;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^32$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size94 = 0;
          $self->{compression_options} = {};
          my $_ktype95 = 0;
          my $_vtype96 = 0;
          $xfer += $input->readMapBegin(\$_ktype95, \$_vtype96, \$_size94);
          for (my $_i98 = 0; $_i98 < $_size94; ++$_i98)
          {
            my $key99 = '';
            my $val100 = '';
            $xfer += $input->readString(\$key99);
            $xfer += $input->readString(\$val100);
            $self->{compression_options}->{$key99} = $val100;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^33$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{bloom_filter_fp_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^34$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{caching});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^37$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{dclocal_read_repair_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{row_cache_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{key_cache_size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^19$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{row_cache_save_period_in_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^20$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{key_cache_save_period_in_seconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^21$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{memtable_flush_after_mins});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^22$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{memtable_throughput_in_mb});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^23$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{memtable_operations_in_millions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^25$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{merge_shards_chance});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^27$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row_cache_provider});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^31$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{row_cache_keys_to_save});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CfDef');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_type}) {
    $xfer += $output->writeFieldBegin('column_type', TType::STRING, 3);
    $xfer += $output->writeString($self->{column_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comparator_type}) {
    $xfer += $output->writeFieldBegin('comparator_type', TType::STRING, 5);
    $xfer += $output->writeString($self->{comparator_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subcomparator_type}) {
    $xfer += $output->writeFieldBegin('subcomparator_type', TType::STRING, 6);
    $xfer += $output->writeString($self->{subcomparator_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comment}) {
    $xfer += $output->writeFieldBegin('comment', TType::STRING, 8);
    $xfer += $output->writeString($self->{comment});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_size}) {
    $xfer += $output->writeFieldBegin('row_cache_size', TType::DOUBLE, 9);
    $xfer += $output->writeDouble($self->{row_cache_size});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_cache_size}) {
    $xfer += $output->writeFieldBegin('key_cache_size', TType::DOUBLE, 11);
    $xfer += $output->writeDouble($self->{key_cache_size});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_repair_chance}) {
    $xfer += $output->writeFieldBegin('read_repair_chance', TType::DOUBLE, 12);
    $xfer += $output->writeDouble($self->{read_repair_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_metadata}) {
    $xfer += $output->writeFieldBegin('column_metadata', TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{column_metadata}}));
      {
        foreach my $iter101 (@{$self->{column_metadata}}) 
        {
          $xfer += ${iter101}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gc_grace_seconds}) {
    $xfer += $output->writeFieldBegin('gc_grace_seconds', TType::I32, 14);
    $xfer += $output->writeI32($self->{gc_grace_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_validation_class}) {
    $xfer += $output->writeFieldBegin('default_validation_class', TType::STRING, 15);
    $xfer += $output->writeString($self->{default_validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 16);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{min_compaction_threshold}) {
    $xfer += $output->writeFieldBegin('min_compaction_threshold', TType::I32, 17);
    $xfer += $output->writeI32($self->{min_compaction_threshold});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_compaction_threshold}) {
    $xfer += $output->writeFieldBegin('max_compaction_threshold', TType::I32, 18);
    $xfer += $output->writeI32($self->{max_compaction_threshold});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_save_period_in_seconds}) {
    $xfer += $output->writeFieldBegin('row_cache_save_period_in_seconds', TType::I32, 19);
    $xfer += $output->writeI32($self->{row_cache_save_period_in_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_cache_save_period_in_seconds}) {
    $xfer += $output->writeFieldBegin('key_cache_save_period_in_seconds', TType::I32, 20);
    $xfer += $output->writeI32($self->{key_cache_save_period_in_seconds});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_flush_after_mins}) {
    $xfer += $output->writeFieldBegin('memtable_flush_after_mins', TType::I32, 21);
    $xfer += $output->writeI32($self->{memtable_flush_after_mins});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_throughput_in_mb}) {
    $xfer += $output->writeFieldBegin('memtable_throughput_in_mb', TType::I32, 22);
    $xfer += $output->writeI32($self->{memtable_throughput_in_mb});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{memtable_operations_in_millions}) {
    $xfer += $output->writeFieldBegin('memtable_operations_in_millions', TType::DOUBLE, 23);
    $xfer += $output->writeDouble($self->{memtable_operations_in_millions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replicate_on_write}) {
    $xfer += $output->writeFieldBegin('replicate_on_write', TType::BOOL, 24);
    $xfer += $output->writeBool($self->{replicate_on_write});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{merge_shards_chance}) {
    $xfer += $output->writeFieldBegin('merge_shards_chance', TType::DOUBLE, 25);
    $xfer += $output->writeDouble($self->{merge_shards_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_validation_class}) {
    $xfer += $output->writeFieldBegin('key_validation_class', TType::STRING, 26);
    $xfer += $output->writeString($self->{key_validation_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_provider}) {
    $xfer += $output->writeFieldBegin('row_cache_provider', TType::STRING, 27);
    $xfer += $output->writeString($self->{row_cache_provider});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{key_alias}) {
    $xfer += $output->writeFieldBegin('key_alias', TType::STRING, 28);
    $xfer += $output->writeString($self->{key_alias});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compaction_strategy}) {
    $xfer += $output->writeFieldBegin('compaction_strategy', TType::STRING, 29);
    $xfer += $output->writeString($self->{compaction_strategy});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compaction_strategy_options}) {
    $xfer += $output->writeFieldBegin('compaction_strategy_options', TType::MAP, 30);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{compaction_strategy_options}}));
      {
        while( my ($kiter102,$viter103) = each %{$self->{compaction_strategy_options}}) 
        {
          $xfer += $output->writeString($kiter102);
          $xfer += $output->writeString($viter103);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row_cache_keys_to_save}) {
    $xfer += $output->writeFieldBegin('row_cache_keys_to_save', TType::I32, 31);
    $xfer += $output->writeI32($self->{row_cache_keys_to_save});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression_options}) {
    $xfer += $output->writeFieldBegin('compression_options', TType::MAP, 32);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{compression_options}}));
      {
        while( my ($kiter104,$viter105) = each %{$self->{compression_options}}) 
        {
          $xfer += $output->writeString($kiter104);
          $xfer += $output->writeString($viter105);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bloom_filter_fp_chance}) {
    $xfer += $output->writeFieldBegin('bloom_filter_fp_chance', TType::DOUBLE, 33);
    $xfer += $output->writeDouble($self->{bloom_filter_fp_chance});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{caching}) {
    $xfer += $output->writeFieldBegin('caching', TType::STRING, 34);
    $xfer += $output->writeString($self->{caching});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dclocal_read_repair_chance}) {
    $xfer += $output->writeFieldBegin('dclocal_read_repair_chance', TType::DOUBLE, 37);
    $xfer += $output->writeDouble($self->{dclocal_read_repair_chance});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::KsDef;
use base qw(Class::Accessor);
Cassandra::KsDef->mk_accessors( qw( name strategy_class strategy_options replication_factor cf_defs durable_writes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{strategy_class} = undef;
  $self->{strategy_options} = undef;
  $self->{replication_factor} = undef;
  $self->{cf_defs} = undef;
  $self->{durable_writes} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{strategy_class}) {
      $self->{strategy_class} = $vals->{strategy_class};
    }
    if (defined $vals->{strategy_options}) {
      $self->{strategy_options} = $vals->{strategy_options};
    }
    if (defined $vals->{replication_factor}) {
      $self->{replication_factor} = $vals->{replication_factor};
    }
    if (defined $vals->{cf_defs}) {
      $self->{cf_defs} = $vals->{cf_defs};
    }
    if (defined $vals->{durable_writes}) {
      $self->{durable_writes} = $vals->{durable_writes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'KsDef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{strategy_class});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size106 = 0;
          $self->{strategy_options} = {};
          my $_ktype107 = 0;
          my $_vtype108 = 0;
          $xfer += $input->readMapBegin(\$_ktype107, \$_vtype108, \$_size106);
          for (my $_i110 = 0; $_i110 < $_size106; ++$_i110)
          {
            my $key111 = '';
            my $val112 = '';
            $xfer += $input->readString(\$key111);
            $xfer += $input->readString(\$val112);
            $self->{strategy_options}->{$key111} = $val112;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{replication_factor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size113 = 0;
          $self->{cf_defs} = [];
          my $_etype116 = 0;
          $xfer += $input->readListBegin(\$_etype116, \$_size113);
          for (my $_i117 = 0; $_i117 < $_size113; ++$_i117)
          {
            my $elem118 = undef;
            $elem118 = new Cassandra::CfDef();
            $xfer += $elem118->read($input);
            push(@{$self->{cf_defs}},$elem118);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{durable_writes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('KsDef');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strategy_class}) {
    $xfer += $output->writeFieldBegin('strategy_class', TType::STRING, 2);
    $xfer += $output->writeString($self->{strategy_class});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strategy_options}) {
    $xfer += $output->writeFieldBegin('strategy_options', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{strategy_options}}));
      {
        while( my ($kiter119,$viter120) = each %{$self->{strategy_options}}) 
        {
          $xfer += $output->writeString($kiter119);
          $xfer += $output->writeString($viter120);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replication_factor}) {
    $xfer += $output->writeFieldBegin('replication_factor', TType::I32, 4);
    $xfer += $output->writeI32($self->{replication_factor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cf_defs}) {
    $xfer += $output->writeFieldBegin('cf_defs', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cf_defs}}));
      {
        foreach my $iter121 (@{$self->{cf_defs}}) 
        {
          $xfer += ${iter121}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{durable_writes}) {
    $xfer += $output->writeFieldBegin('durable_writes', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{durable_writes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlRow;
use base qw(Class::Accessor);
Cassandra::CqlRow->mk_accessors( qw( key columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlRow';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size122 = 0;
          $self->{columns} = [];
          my $_etype125 = 0;
          $xfer += $input->readListBegin(\$_etype125, \$_size122);
          for (my $_i126 = 0; $_i126 < $_size122; ++$_i126)
          {
            my $elem127 = undef;
            $elem127 = new Cassandra::Column();
            $xfer += $elem127->read($input);
            push(@{$self->{columns}},$elem127);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlRow');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter128 (@{$self->{columns}}) 
        {
          $xfer += ${iter128}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlMetadata;
use base qw(Class::Accessor);
Cassandra::CqlMetadata->mk_accessors( qw( name_types value_types default_name_type default_value_type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name_types} = undef;
  $self->{value_types} = undef;
  $self->{default_name_type} = undef;
  $self->{default_value_type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name_types}) {
      $self->{name_types} = $vals->{name_types};
    }
    if (defined $vals->{value_types}) {
      $self->{value_types} = $vals->{value_types};
    }
    if (defined $vals->{default_name_type}) {
      $self->{default_name_type} = $vals->{default_name_type};
    }
    if (defined $vals->{default_value_type}) {
      $self->{default_value_type} = $vals->{default_value_type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlMetadata';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size129 = 0;
          $self->{name_types} = {};
          my $_ktype130 = 0;
          my $_vtype131 = 0;
          $xfer += $input->readMapBegin(\$_ktype130, \$_vtype131, \$_size129);
          for (my $_i133 = 0; $_i133 < $_size129; ++$_i133)
          {
            my $key134 = '';
            my $val135 = '';
            $xfer += $input->readString(\$key134);
            $xfer += $input->readString(\$val135);
            $self->{name_types}->{$key134} = $val135;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size136 = 0;
          $self->{value_types} = {};
          my $_ktype137 = 0;
          my $_vtype138 = 0;
          $xfer += $input->readMapBegin(\$_ktype137, \$_vtype138, \$_size136);
          for (my $_i140 = 0; $_i140 < $_size136; ++$_i140)
          {
            my $key141 = '';
            my $val142 = '';
            $xfer += $input->readString(\$key141);
            $xfer += $input->readString(\$val142);
            $self->{value_types}->{$key141} = $val142;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{default_name_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{default_value_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlMetadata');
  if (defined $self->{name_types}) {
    $xfer += $output->writeFieldBegin('name_types', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{name_types}}));
      {
        while( my ($kiter143,$viter144) = each %{$self->{name_types}}) 
        {
          $xfer += $output->writeString($kiter143);
          $xfer += $output->writeString($viter144);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value_types}) {
    $xfer += $output->writeFieldBegin('value_types', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{value_types}}));
      {
        while( my ($kiter145,$viter146) = each %{$self->{value_types}}) 
        {
          $xfer += $output->writeString($kiter145);
          $xfer += $output->writeString($viter146);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_name_type}) {
    $xfer += $output->writeFieldBegin('default_name_type', TType::STRING, 3);
    $xfer += $output->writeString($self->{default_name_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{default_value_type}) {
    $xfer += $output->writeFieldBegin('default_value_type', TType::STRING, 4);
    $xfer += $output->writeString($self->{default_value_type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlResult;
use base qw(Class::Accessor);
Cassandra::CqlResult->mk_accessors( qw( type rows num schema ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  $self->{rows} = undef;
  $self->{num} = undef;
  $self->{schema} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{num}) {
      $self->{num} = $vals->{num};
    }
    if (defined $vals->{schema}) {
      $self->{schema} = $vals->{schema};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size147 = 0;
          $self->{rows} = [];
          my $_etype150 = 0;
          $xfer += $input->readListBegin(\$_etype150, \$_size147);
          for (my $_i151 = 0; $_i151 < $_size147; ++$_i151)
          {
            my $elem152 = undef;
            $elem152 = new Cassandra::CqlRow();
            $xfer += $elem152->read($input);
            push(@{$self->{rows}},$elem152);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{num});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{schema} = new Cassandra::CqlMetadata();
        $xfer += $self->{schema}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlResult');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 1);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rows}}));
      {
        foreach my $iter153 (@{$self->{rows}}) 
        {
          $xfer += ${iter153}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{num}) {
    $xfer += $output->writeFieldBegin('num', TType::I32, 3);
    $xfer += $output->writeI32($self->{num});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{schema}) {
    $xfer += $output->writeFieldBegin('schema', TType::STRUCT, 4);
    $xfer += $self->{schema}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CqlPreparedResult;
use base qw(Class::Accessor);
Cassandra::CqlPreparedResult->mk_accessors( qw( itemId count variable_types ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{itemId} = undef;
  $self->{count} = undef;
  $self->{variable_types} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
    if (defined $vals->{count}) {
      $self->{count} = $vals->{count};
    }
    if (defined $vals->{variable_types}) {
      $self->{variable_types} = $vals->{variable_types};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CqlPreparedResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{count});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size154 = 0;
          $self->{variable_types} = [];
          my $_etype157 = 0;
          $xfer += $input->readListBegin(\$_etype157, \$_size154);
          for (my $_i158 = 0; $_i158 < $_size154; ++$_i158)
          {
            my $elem159 = undef;
            $xfer += $input->readString(\$elem159);
            push(@{$self->{variable_types}},$elem159);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CqlPreparedResult');
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', TType::I32, 1);
    $xfer += $output->writeI32($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{count}) {
    $xfer += $output->writeFieldBegin('count', TType::I32, 2);
    $xfer += $output->writeI32($self->{count});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{variable_types}) {
    $xfer += $output->writeFieldBegin('variable_types', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{variable_types}}));
      {
        foreach my $iter160 (@{$self->{variable_types}}) 
        {
          $xfer += $output->writeString($iter160);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
