#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Cassandra::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Cassandra::Cassandra_login_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_login_args->mk_accessors( qw( auth_request ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{auth_request} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{auth_request}) {
      $self->{auth_request} = $vals->{auth_request};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_login_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{auth_request} = new Cassandra::AuthenticationRequest();
        $xfer += $self->{auth_request}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_login_args');
  if (defined $self->{auth_request}) {
    $xfer += $output->writeFieldBegin('auth_request', TType::STRUCT, 1);
    $xfer += $self->{auth_request}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_login_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_login_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authnx} = undef;
  $self->{authzx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authnx}) {
      $self->{authnx} = $vals->{authnx};
    }
    if (defined $vals->{authzx}) {
      $self->{authzx} = $vals->{authzx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_login_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{authnx} = new Cassandra::AuthenticationException();
        $xfer += $self->{authnx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{authzx} = new Cassandra::AuthorizationException();
        $xfer += $self->{authzx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_login_result');
  if (defined $self->{authnx}) {
    $xfer += $output->writeFieldBegin('authnx', TType::STRUCT, 1);
    $xfer += $self->{authnx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{authzx}) {
    $xfer += $output->writeFieldBegin('authzx', TType::STRUCT, 2);
    $xfer += $self->{authzx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_keyspace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_keyspace_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_args->mk_accessors( qw( key column_path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_path} = new Cassandra::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', TType::STRUCT, 2);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{nfe} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::ColumnOrSuperColumn();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{nfe} = new Cassandra::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 3);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 4);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_slice_args->mk_accessors( qw( key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size168 = 0;
          $self->{success} = [];
          my $_etype171 = 0;
          $xfer += $input->readListBegin(\$_etype171, \$_size168);
          for (my $_i172 = 0; $_i172 < $_size168; ++$_i172)
          {
            my $elem173 = undef;
            $elem173 = new Cassandra::ColumnOrSuperColumn();
            $xfer += $elem173->read($input);
            push(@{$self->{success}},$elem173);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter174 (@{$self->{success}}) 
        {
          $xfer += ${iter174}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_count_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_count_args->mk_accessors( qw( key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_count_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_slice_args->mk_accessors( qw( keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size175 = 0;
          $self->{keys} = [];
          my $_etype178 = 0;
          $xfer += $input->readListBegin(\$_etype178, \$_size175);
          for (my $_i179 = 0; $_i179 < $_size175; ++$_i179)
          {
            my $elem180 = undef;
            $xfer += $input->readString(\$elem180);
            push(@{$self->{keys}},$elem180);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_args');
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter181 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter181);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size182 = 0;
          $self->{success} = {};
          my $_ktype183 = 0;
          my $_vtype184 = 0;
          $xfer += $input->readMapBegin(\$_ktype183, \$_vtype184, \$_size182);
          for (my $_i186 = 0; $_i186 < $_size182; ++$_i186)
          {
            my $key187 = '';
            my $val188 = [];
            $xfer += $input->readString(\$key187);
            {
              my $_size189 = 0;
              $val188 = [];
              my $_etype192 = 0;
              $xfer += $input->readListBegin(\$_etype192, \$_size189);
              for (my $_i193 = 0; $_i193 < $_size189; ++$_i193)
              {
                my $elem194 = undef;
                $elem194 = new Cassandra::ColumnOrSuperColumn();
                $xfer += $elem194->read($input);
                push(@{$val188},$elem194);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key187} = $val188;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter195,$viter196) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter195);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter196}}));
            {
              foreach my $iter197 (@{${viter196}}) 
              {
                $xfer += ${iter197}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_count_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_count_args->mk_accessors( qw( keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size198 = 0;
          $self->{keys} = [];
          my $_etype201 = 0;
          $xfer += $input->readListBegin(\$_etype201, \$_size198);
          for (my $_i202 = 0; $_i202 < $_size198; ++$_i202)
          {
            my $elem203 = undef;
            $xfer += $input->readString(\$elem203);
            push(@{$self->{keys}},$elem203);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_count_args');
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter204 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter204);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_count_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size205 = 0;
          $self->{success} = {};
          my $_ktype206 = 0;
          my $_vtype207 = 0;
          $xfer += $input->readMapBegin(\$_ktype206, \$_vtype207, \$_size205);
          for (my $_i209 = 0; $_i209 < $_size205; ++$_i209)
          {
            my $key210 = '';
            my $val211 = 0;
            $xfer += $input->readString(\$key210);
            $xfer += $input->readI32(\$val211);
            $self->{success}->{$key210} = $val211;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter212,$viter213) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter212);
          $xfer += $output->writeI32($viter213);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_range_slices_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_range_slices_args->mk_accessors( qw( column_parent predicate range consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{range} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{range}) {
      $self->{range} = $vals->{range};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slices_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{range} = new Cassandra::KeyRange();
        $xfer += $self->{range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slices_args');
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 1);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 2);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{range}) {
    $xfer += $output->writeFieldBegin('range', TType::STRUCT, 3);
    $xfer += $self->{range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_range_slices_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_range_slices_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slices_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size214 = 0;
          $self->{success} = [];
          my $_etype217 = 0;
          $xfer += $input->readListBegin(\$_etype217, \$_size214);
          for (my $_i218 = 0; $_i218 < $_size214; ++$_i218)
          {
            my $elem219 = undef;
            $elem219 = new Cassandra::KeySlice();
            $xfer += $elem219->read($input);
            push(@{$self->{success}},$elem219);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter220 (@{$self->{success}}) 
        {
          $xfer += ${iter220}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_paged_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_paged_slice_args->mk_accessors( qw( column_family range start_column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{range} = undef;
  $self->{start_column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{range}) {
      $self->{range} = $vals->{range};
    }
    if (defined $vals->{start_column}) {
      $self->{start_column} = $vals->{start_column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_paged_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{range} = new Cassandra::KeyRange();
        $xfer += $self->{range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_paged_slice_args');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{range}) {
    $xfer += $output->writeFieldBegin('range', TType::STRUCT, 2);
    $xfer += $self->{range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_column}) {
    $xfer += $output->writeFieldBegin('start_column', TType::STRING, 3);
    $xfer += $output->writeString($self->{start_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_paged_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_paged_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_paged_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size221 = 0;
          $self->{success} = [];
          my $_etype224 = 0;
          $xfer += $input->readListBegin(\$_etype224, \$_size221);
          for (my $_i225 = 0; $_i225 < $_size221; ++$_i225)
          {
            my $elem226 = undef;
            $elem226 = new Cassandra::KeySlice();
            $xfer += $elem226->read($input);
            push(@{$self->{success}},$elem226);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_paged_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter227 (@{$self->{success}}) 
        {
          $xfer += ${iter227}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_indexed_slices_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_indexed_slices_args->mk_accessors( qw( column_parent index_clause column_predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_parent} = undef;
  $self->{index_clause} = undef;
  $self->{column_predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{index_clause}) {
      $self->{index_clause} = $vals->{index_clause};
    }
    if (defined $vals->{column_predicate}) {
      $self->{column_predicate} = $vals->{column_predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_indexed_slices_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{index_clause} = new Cassandra::IndexClause();
        $xfer += $self->{index_clause}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{column_predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_indexed_slices_args');
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 1);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_clause}) {
    $xfer += $output->writeFieldBegin('index_clause', TType::STRUCT, 2);
    $xfer += $self->{index_clause}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_predicate}) {
    $xfer += $output->writeFieldBegin('column_predicate', TType::STRUCT, 3);
    $xfer += $self->{column_predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_indexed_slices_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_indexed_slices_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_indexed_slices_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size228 = 0;
          $self->{success} = [];
          my $_etype231 = 0;
          $xfer += $input->readListBegin(\$_etype231, \$_size228);
          for (my $_i232 = 0; $_i232 < $_size228; ++$_i232)
          {
            my $elem233 = undef;
            $elem233 = new Cassandra::KeySlice();
            $xfer += $elem233->read($input);
            push(@{$self->{success}},$elem233);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_indexed_slices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter234 (@{$self->{success}}) 
        {
          $xfer += ${iter234}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_insert_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_insert_args->mk_accessors( qw( key column_parent column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::Column();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 3);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_insert_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_insert_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_add_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_add_args->mk_accessors( qw( key column_parent column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_add_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::CounterColumn();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_add_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 3);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_add_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_add_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_add_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_add_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_args->mk_accessors( qw( key column_path timestamp consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{timestamp} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_path} = new Cassandra::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', TType::STRUCT, 2);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_counter_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_counter_args->mk_accessors( qw( key path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_counter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Cassandra::ColumnPath();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_counter_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 2);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_counter_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_counter_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_counter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_counter_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_batch_mutate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_batch_mutate_args->mk_accessors( qw( mutation_map consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation_map} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation_map}) {
      $self->{mutation_map} = $vals->{mutation_map};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size235 = 0;
          $self->{mutation_map} = {};
          my $_ktype236 = 0;
          my $_vtype237 = 0;
          $xfer += $input->readMapBegin(\$_ktype236, \$_vtype237, \$_size235);
          for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
          {
            my $key240 = '';
            my $val241 = [];
            $xfer += $input->readString(\$key240);
            {
              my $_size242 = 0;
              $val241 = {};
              my $_ktype243 = 0;
              my $_vtype244 = 0;
              $xfer += $input->readMapBegin(\$_ktype243, \$_vtype244, \$_size242);
              for (my $_i246 = 0; $_i246 < $_size242; ++$_i246)
              {
                my $key247 = '';
                my $val248 = [];
                $xfer += $input->readString(\$key247);
                {
                  my $_size249 = 0;
                  $val248 = [];
                  my $_etype252 = 0;
                  $xfer += $input->readListBegin(\$_etype252, \$_size249);
                  for (my $_i253 = 0; $_i253 < $_size249; ++$_i253)
                  {
                    my $elem254 = undef;
                    $elem254 = new Cassandra::Mutation();
                    $xfer += $elem254->read($input);
                    push(@{$val248},$elem254);
                  }
                  $xfer += $input->readListEnd();
                }
                $val241->{$key247} = $val248;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{mutation_map}->{$key240} = $val241;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_mutate_args');
  if (defined $self->{mutation_map}) {
    $xfer += $output->writeFieldBegin('mutation_map', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{mutation_map}}));
      {
        while( my ($kiter255,$viter256) = each %{$self->{mutation_map}}) 
        {
          $xfer += $output->writeString($kiter255);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{${viter256}}));
            {
              while( my ($kiter257,$viter258) = each %{${viter256}}) 
              {
                $xfer += $output->writeString($kiter257);
                {
                  $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter258}}));
                  {
                    foreach my $iter259 (@{${viter258}}) 
                    {
                      $xfer += ${iter259}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_batch_mutate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_batch_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_mutate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_atomic_batch_mutate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_atomic_batch_mutate_args->mk_accessors( qw( mutation_map consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation_map} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation_map}) {
      $self->{mutation_map} = $vals->{mutation_map};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_atomic_batch_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size260 = 0;
          $self->{mutation_map} = {};
          my $_ktype261 = 0;
          my $_vtype262 = 0;
          $xfer += $input->readMapBegin(\$_ktype261, \$_vtype262, \$_size260);
          for (my $_i264 = 0; $_i264 < $_size260; ++$_i264)
          {
            my $key265 = '';
            my $val266 = [];
            $xfer += $input->readString(\$key265);
            {
              my $_size267 = 0;
              $val266 = {};
              my $_ktype268 = 0;
              my $_vtype269 = 0;
              $xfer += $input->readMapBegin(\$_ktype268, \$_vtype269, \$_size267);
              for (my $_i271 = 0; $_i271 < $_size267; ++$_i271)
              {
                my $key272 = '';
                my $val273 = [];
                $xfer += $input->readString(\$key272);
                {
                  my $_size274 = 0;
                  $val273 = [];
                  my $_etype277 = 0;
                  $xfer += $input->readListBegin(\$_etype277, \$_size274);
                  for (my $_i278 = 0; $_i278 < $_size274; ++$_i278)
                  {
                    my $elem279 = undef;
                    $elem279 = new Cassandra::Mutation();
                    $xfer += $elem279->read($input);
                    push(@{$val273},$elem279);
                  }
                  $xfer += $input->readListEnd();
                }
                $val266->{$key272} = $val273;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{mutation_map}->{$key265} = $val266;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_atomic_batch_mutate_args');
  if (defined $self->{mutation_map}) {
    $xfer += $output->writeFieldBegin('mutation_map', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{mutation_map}}));
      {
        while( my ($kiter280,$viter281) = each %{$self->{mutation_map}}) 
        {
          $xfer += $output->writeString($kiter280);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{${viter281}}));
            {
              while( my ($kiter282,$viter283) = each %{${viter281}}) 
              {
                $xfer += $output->writeString($kiter282);
                {
                  $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter283}}));
                  {
                    foreach my $iter284 (@{${viter283}}) 
                    {
                      $xfer += ${iter284}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_atomic_batch_mutate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_atomic_batch_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_atomic_batch_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_atomic_batch_mutate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_truncate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_truncate_args->mk_accessors( qw( cfname ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfname} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfname}) {
      $self->{cfname} = $vals->{cfname};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_truncate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cfname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_truncate_args');
  if (defined $self->{cfname}) {
    $xfer += $output->writeFieldBegin('cfname', TType::STRING, 1);
    $xfer += $output->writeString($self->{cfname});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_truncate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_truncate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_truncate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_truncate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_schema_versions_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_schema_versions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_schema_versions_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_schema_versions_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_schema_versions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_schema_versions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size285 = 0;
          $self->{success} = {};
          my $_ktype286 = 0;
          my $_vtype287 = 0;
          $xfer += $input->readMapBegin(\$_ktype286, \$_vtype287, \$_size285);
          for (my $_i289 = 0; $_i289 < $_size285; ++$_i289)
          {
            my $key290 = '';
            my $val291 = [];
            $xfer += $input->readString(\$key290);
            {
              my $_size292 = 0;
              $val291 = [];
              my $_etype295 = 0;
              $xfer += $input->readListBegin(\$_etype295, \$_size292);
              for (my $_i296 = 0; $_i296 < $_size292; ++$_i296)
              {
                my $elem297 = undef;
                $xfer += $input->readString(\$elem297);
                push(@{$val291},$elem297);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key290} = $val291;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_schema_versions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter298,$viter299) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter298);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter299}}));
            {
              foreach my $iter300 (@{${viter299}}) 
              {
                $xfer += $output->writeString($iter300);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspaces_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspaces_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspaces_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspaces_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspaces_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspaces_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size301 = 0;
          $self->{success} = [];
          my $_etype304 = 0;
          $xfer += $input->readListBegin(\$_etype304, \$_size301);
          for (my $_i305 = 0; $_i305 < $_size301; ++$_i305)
          {
            my $elem306 = undef;
            $elem306 = new Cassandra::KsDef();
            $xfer += $elem306->read($input);
            push(@{$self->{success}},$elem306);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspaces_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter307 (@{$self->{success}}) 
        {
          $xfer += ${iter307}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_cluster_name_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_cluster_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_cluster_name_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_cluster_name_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_cluster_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_cluster_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_cluster_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_version_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_version_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_version_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_version_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_version_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_version_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_version_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_ring_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_ring_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_ring_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_ring_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_ring_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_ring_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_ring_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size308 = 0;
          $self->{success} = [];
          my $_etype311 = 0;
          $xfer += $input->readListBegin(\$_etype311, \$_size308);
          for (my $_i312 = 0; $_i312 < $_size308; ++$_i312)
          {
            my $elem313 = undef;
            $elem313 = new Cassandra::TokenRange();
            $xfer += $elem313->read($input);
            push(@{$self->{success}},$elem313);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_ring_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter314 (@{$self->{success}}) 
        {
          $xfer += ${iter314}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_token_map_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_token_map_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_token_map_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_token_map_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_token_map_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_token_map_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size315 = 0;
          $self->{success} = {};
          my $_ktype316 = 0;
          my $_vtype317 = 0;
          $xfer += $input->readMapBegin(\$_ktype316, \$_vtype317, \$_size315);
          for (my $_i319 = 0; $_i319 < $_size315; ++$_i319)
          {
            my $key320 = '';
            my $val321 = '';
            $xfer += $input->readString(\$key320);
            $xfer += $input->readString(\$val321);
            $self->{success}->{$key320} = $val321;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_token_map_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter322,$viter323) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter322);
          $xfer += $output->writeString($viter323);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_partitioner_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_partitioner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_partitioner_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_partitioner_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_partitioner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_partitioner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_partitioner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_snitch_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_snitch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_snitch_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_snitch_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_snitch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_snitch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_snitch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{nfe} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::KsDef();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{nfe} = new Cassandra::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', TType::STRUCT, 1);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 2);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_args->mk_accessors( qw( cfName start_token end_token keys_per_split ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfName} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{keys_per_split} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfName}) {
      $self->{cfName} = $vals->{cfName};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{keys_per_split}) {
      $self->{keys_per_split} = $vals->{keys_per_split};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cfName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{keys_per_split});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_args');
  if (defined $self->{cfName}) {
    $xfer += $output->writeFieldBegin('cfName', TType::STRING, 1);
    $xfer += $output->writeString($self->{cfName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 2);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 3);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys_per_split}) {
    $xfer += $output->writeFieldBegin('keys_per_split', TType::I32, 4);
    $xfer += $output->writeI32($self->{keys_per_split});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size324 = 0;
          $self->{success} = [];
          my $_etype327 = 0;
          $xfer += $input->readListBegin(\$_etype327, \$_size324);
          for (my $_i328 = 0; $_i328 < $_size324; ++$_i328)
          {
            my $elem329 = undef;
            $xfer += $input->readString(\$elem329);
            push(@{$self->{success}},$elem329);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter330 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter330);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_trace_next_query_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_trace_next_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_trace_next_query_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_trace_next_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_trace_next_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_trace_next_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_trace_next_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_ex_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_ex_args->mk_accessors( qw( cfName start_token end_token keys_per_split ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfName} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{keys_per_split} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfName}) {
      $self->{cfName} = $vals->{cfName};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{keys_per_split}) {
      $self->{keys_per_split} = $vals->{keys_per_split};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_ex_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cfName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{keys_per_split});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_ex_args');
  if (defined $self->{cfName}) {
    $xfer += $output->writeFieldBegin('cfName', TType::STRING, 1);
    $xfer += $output->writeString($self->{cfName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 2);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 3);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys_per_split}) {
    $xfer += $output->writeFieldBegin('keys_per_split', TType::I32, 4);
    $xfer += $output->writeI32($self->{keys_per_split});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_ex_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_ex_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_ex_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size331 = 0;
          $self->{success} = [];
          my $_etype334 = 0;
          $xfer += $input->readListBegin(\$_etype334, \$_size331);
          for (my $_i335 = 0; $_i335 < $_size331; ++$_i335)
          {
            my $elem336 = undef;
            $elem336 = new Cassandra::CfSplit();
            $xfer += $elem336->read($input);
            push(@{$self->{success}},$elem336);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_ex_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter337 (@{$self->{success}}) 
        {
          $xfer += ${iter337}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_column_family_args->mk_accessors( qw( cf_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cf_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cf_def}) {
      $self->{cf_def} = $vals->{cf_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cf_def} = new Cassandra::CfDef();
        $xfer += $self->{cf_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_column_family_args');
  if (defined $self->{cf_def}) {
    $xfer += $output->writeFieldBegin('cf_def', TType::STRUCT, 1);
    $xfer += $self->{cf_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_column_family_args->mk_accessors( qw( column_family ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_column_family_args');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_keyspace_args->mk_accessors( qw( ks_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ks_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ks_def}) {
      $self->{ks_def} = $vals->{ks_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ks_def} = new Cassandra::KsDef();
        $xfer += $self->{ks_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_keyspace_args');
  if (defined $self->{ks_def}) {
    $xfer += $output->writeFieldBegin('ks_def', TType::STRUCT, 1);
    $xfer += $self->{ks_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_keyspace_args->mk_accessors( qw( ks_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ks_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ks_def}) {
      $self->{ks_def} = $vals->{ks_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ks_def} = new Cassandra::KsDef();
        $xfer += $self->{ks_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_keyspace_args');
  if (defined $self->{ks_def}) {
    $xfer += $output->writeFieldBegin('ks_def', TType::STRUCT, 1);
    $xfer += $self->{ks_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_column_family_args->mk_accessors( qw( cf_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cf_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cf_def}) {
      $self->{cf_def} = $vals->{cf_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cf_def} = new Cassandra::CfDef();
        $xfer += $self->{cf_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_column_family_args');
  if (defined $self->{cf_def}) {
    $xfer += $output->writeFieldBegin('cf_def', TType::STRUCT, 1);
    $xfer += $self->{cf_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql3_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql3_query_args->mk_accessors( qw( query compression consistency ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  $self->{consistency} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
    if (defined $vals->{consistency}) {
      $self->{consistency} = $vals->{consistency};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql3_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql3_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency}) {
    $xfer += $output->writeFieldBegin('consistency', TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql3_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql3_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql3_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql3_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlPreparedResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql3_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql3_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql3_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql3_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql3_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql3_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql3_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlPreparedResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql3_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql_query_args->mk_accessors( qw( itemId values ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{itemId} = undef;
  $self->{values} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
    if (defined $vals->{values}) {
      $self->{values} = $vals->{values};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size338 = 0;
          $self->{values} = [];
          my $_etype341 = 0;
          $xfer += $input->readListBegin(\$_etype341, \$_size338);
          for (my $_i342 = 0; $_i342 < $_size338; ++$_i342)
          {
            my $elem343 = undef;
            $xfer += $input->readString(\$elem343);
            push(@{$self->{values}},$elem343);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql_query_args');
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', TType::I32, 1);
    $xfer += $output->writeI32($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{values}) {
    $xfer += $output->writeFieldBegin('values', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{values}}));
      {
        foreach my $iter344 (@{$self->{values}}) 
        {
          $xfer += $output->writeString($iter344);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql3_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql3_query_args->mk_accessors( qw( itemId values consistency ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{itemId} = undef;
  $self->{values} = undef;
  $self->{consistency} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
    if (defined $vals->{values}) {
      $self->{values} = $vals->{values};
    }
    if (defined $vals->{consistency}) {
      $self->{consistency} = $vals->{consistency};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql3_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size345 = 0;
          $self->{values} = [];
          my $_etype348 = 0;
          $xfer += $input->readListBegin(\$_etype348, \$_size345);
          for (my $_i349 = 0; $_i349 < $_size345; ++$_i349)
          {
            my $elem350 = undef;
            $xfer += $input->readString(\$elem350);
            push(@{$self->{values}},$elem350);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql3_query_args');
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', TType::I32, 1);
    $xfer += $output->writeI32($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{values}) {
    $xfer += $output->writeFieldBegin('values', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{values}}));
      {
        foreach my $iter351 (@{$self->{values}}) 
        {
          $xfer += $output->writeString($iter351);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency}) {
    $xfer += $output->writeFieldBegin('consistency', TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql3_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql3_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql3_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql3_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_cql_version_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_cql_version_args->mk_accessors( qw( version ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{version} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_cql_version_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_cql_version_args');
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::STRING, 1);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_cql_version_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_cql_version_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_cql_version_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_cql_version_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CassandraIf;

use strict;


sub login{
  my $self = shift;
  my $auth_request = shift;

  die 'implement interface';
}

sub set_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub atomic_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub truncate{
  my $self = shift;
  my $cfname = shift;

  die 'implement interface';
}

sub describe_schema_versions{
  my $self = shift;

  die 'implement interface';
}

sub describe_keyspaces{
  my $self = shift;

  die 'implement interface';
}

sub describe_cluster_name{
  my $self = shift;

  die 'implement interface';
}

sub describe_version{
  my $self = shift;

  die 'implement interface';
}

sub describe_ring{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_token_map{
  my $self = shift;

  die 'implement interface';
}

sub describe_partitioner{
  my $self = shift;

  die 'implement interface';
}

sub describe_snitch{
  my $self = shift;

  die 'implement interface';
}

sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  die 'implement interface';
}

sub trace_next_query{
  my $self = shift;

  die 'implement interface';
}

sub describe_splits_ex{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  die 'implement interface';
}

sub system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

  die 'implement interface';
}

sub system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

  die 'implement interface';
}

sub system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

  die 'implement interface';
}

sub system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

  die 'implement interface';
}

sub system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

  die 'implement interface';
}

sub execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

sub execute_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;
  my $consistency = shift;

  die 'implement interface';
}

sub prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

sub prepare_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

sub execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

  die 'implement interface';
}

sub execute_prepared_cql3_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;
  my $consistency = shift;

  die 'implement interface';
}

sub set_cql_version{
  my $self = shift;
  my $version = shift;

  die 'implement interface';
}

package Cassandra::CassandraRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub login{
  my ($self, $request) = @_;

  my $auth_request = ($request->{'auth_request'}) ? $request->{'auth_request'} : undef;
  return $self->{impl}->login($auth_request);
}

sub set_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->set_keyspace($keyspace);
}

sub get{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get($key, $column_path, $consistency_level);
}

sub get_slice{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_slice($key, $column_parent, $predicate, $consistency_level);
}

sub get_count{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_count($key, $column_parent, $predicate, $consistency_level);
}

sub multiget_slice{
  my ($self, $request) = @_;

  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_slice($keys, $column_parent, $predicate, $consistency_level);
}

sub multiget_count{
  my ($self, $request) = @_;

  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_count($keys, $column_parent, $predicate, $consistency_level);
}

sub get_range_slices{
  my ($self, $request) = @_;

  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $range = ($request->{'range'}) ? $request->{'range'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_range_slices($column_parent, $predicate, $range, $consistency_level);
}

sub get_paged_slice{
  my ($self, $request) = @_;

  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  my $range = ($request->{'range'}) ? $request->{'range'} : undef;
  my $start_column = ($request->{'start_column'}) ? $request->{'start_column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_paged_slice($column_family, $range, $start_column, $consistency_level);
}

sub get_indexed_slices{
  my ($self, $request) = @_;

  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $index_clause = ($request->{'index_clause'}) ? $request->{'index_clause'} : undef;
  my $column_predicate = ($request->{'column_predicate'}) ? $request->{'column_predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
}

sub insert{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->insert($key, $column_parent, $column, $consistency_level);
}

sub add{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->add($key, $column_parent, $column, $consistency_level);
}

sub remove{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove($key, $column_path, $timestamp, $consistency_level);
}

sub remove_counter{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove_counter($key, $path, $consistency_level);
}

sub batch_mutate{
  my ($self, $request) = @_;

  my $mutation_map = ($request->{'mutation_map'}) ? $request->{'mutation_map'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->batch_mutate($mutation_map, $consistency_level);
}

sub atomic_batch_mutate{
  my ($self, $request) = @_;

  my $mutation_map = ($request->{'mutation_map'}) ? $request->{'mutation_map'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->atomic_batch_mutate($mutation_map, $consistency_level);
}

sub truncate{
  my ($self, $request) = @_;

  my $cfname = ($request->{'cfname'}) ? $request->{'cfname'} : undef;
  return $self->{impl}->truncate($cfname);
}

sub describe_schema_versions{
  my ($self, $request) = @_;

  return $self->{impl}->describe_schema_versions();
}

sub describe_keyspaces{
  my ($self, $request) = @_;

  return $self->{impl}->describe_keyspaces();
}

sub describe_cluster_name{
  my ($self, $request) = @_;

  return $self->{impl}->describe_cluster_name();
}

sub describe_version{
  my ($self, $request) = @_;

  return $self->{impl}->describe_version();
}

sub describe_ring{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_ring($keyspace);
}

sub describe_token_map{
  my ($self, $request) = @_;

  return $self->{impl}->describe_token_map();
}

sub describe_partitioner{
  my ($self, $request) = @_;

  return $self->{impl}->describe_partitioner();
}

sub describe_snitch{
  my ($self, $request) = @_;

  return $self->{impl}->describe_snitch();
}

sub describe_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_keyspace($keyspace);
}

sub describe_splits{
  my ($self, $request) = @_;

  my $cfName = ($request->{'cfName'}) ? $request->{'cfName'} : undef;
  my $start_token = ($request->{'start_token'}) ? $request->{'start_token'} : undef;
  my $end_token = ($request->{'end_token'}) ? $request->{'end_token'} : undef;
  my $keys_per_split = ($request->{'keys_per_split'}) ? $request->{'keys_per_split'} : undef;
  return $self->{impl}->describe_splits($cfName, $start_token, $end_token, $keys_per_split);
}

sub trace_next_query{
  my ($self, $request) = @_;

  return $self->{impl}->trace_next_query();
}

sub describe_splits_ex{
  my ($self, $request) = @_;

  my $cfName = ($request->{'cfName'}) ? $request->{'cfName'} : undef;
  my $start_token = ($request->{'start_token'}) ? $request->{'start_token'} : undef;
  my $end_token = ($request->{'end_token'}) ? $request->{'end_token'} : undef;
  my $keys_per_split = ($request->{'keys_per_split'}) ? $request->{'keys_per_split'} : undef;
  return $self->{impl}->describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split);
}

sub system_add_column_family{
  my ($self, $request) = @_;

  my $cf_def = ($request->{'cf_def'}) ? $request->{'cf_def'} : undef;
  return $self->{impl}->system_add_column_family($cf_def);
}

sub system_drop_column_family{
  my ($self, $request) = @_;

  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  return $self->{impl}->system_drop_column_family($column_family);
}

sub system_add_keyspace{
  my ($self, $request) = @_;

  my $ks_def = ($request->{'ks_def'}) ? $request->{'ks_def'} : undef;
  return $self->{impl}->system_add_keyspace($ks_def);
}

sub system_drop_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->system_drop_keyspace($keyspace);
}

sub system_update_keyspace{
  my ($self, $request) = @_;

  my $ks_def = ($request->{'ks_def'}) ? $request->{'ks_def'} : undef;
  return $self->{impl}->system_update_keyspace($ks_def);
}

sub system_update_column_family{
  my ($self, $request) = @_;

  my $cf_def = ($request->{'cf_def'}) ? $request->{'cf_def'} : undef;
  return $self->{impl}->system_update_column_family($cf_def);
}

sub execute_cql_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->execute_cql_query($query, $compression);
}

sub execute_cql3_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  my $consistency = ($request->{'consistency'}) ? $request->{'consistency'} : undef;
  return $self->{impl}->execute_cql3_query($query, $compression, $consistency);
}

sub prepare_cql_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->prepare_cql_query($query, $compression);
}

sub prepare_cql3_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->prepare_cql3_query($query, $compression);
}

sub execute_prepared_cql_query{
  my ($self, $request) = @_;

  my $itemId = ($request->{'itemId'}) ? $request->{'itemId'} : undef;
  my $values = ($request->{'values'}) ? $request->{'values'} : undef;
  return $self->{impl}->execute_prepared_cql_query($itemId, $values);
}

sub execute_prepared_cql3_query{
  my ($self, $request) = @_;

  my $itemId = ($request->{'itemId'}) ? $request->{'itemId'} : undef;
  my $values = ($request->{'values'}) ? $request->{'values'} : undef;
  my $consistency = ($request->{'consistency'}) ? $request->{'consistency'} : undef;
  return $self->{impl}->execute_prepared_cql3_query($itemId, $values, $consistency);
}

sub set_cql_version{
  my ($self, $request) = @_;

  my $version = ($request->{'version'}) ? $request->{'version'} : undef;
  return $self->{impl}->set_cql_version($version);
}

package Cassandra::CassandraClient;


use base qw(Cassandra::CassandraIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub login{
  my $self = shift;
  my $auth_request = shift;

    $self->send_login($auth_request);
  $self->recv_login();
}

sub send_login{
  my $self = shift;
  my $auth_request = shift;

  $self->{output}->writeMessageBegin('login', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_login_args();
  $args->{auth_request} = $auth_request;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_login{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_login_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{authnx}) {
    die $result->{authnx};
  }
  if (defined $result->{authzx}) {
    die $result->{authzx};
  }
  return;
}
sub set_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_set_keyspace($keyspace);
  $self->recv_set_keyspace();
}

sub send_set_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('set_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_set_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_set_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  return;
}
sub get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

    $self->send_get($key, $column_path, $consistency_level);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_args();
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    # perlcassa modification for better errors
    use Data::Dumper;
    print STDERR Dumper($result->{ire});
    # end perlcassa modification
    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get failed: unknown result";
}
sub get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_slice($key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_slice();
}

sub send_get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_slice', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_slice_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_slice failed: unknown result";
}
sub get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_count($key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_count();
}

sub send_get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_count', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_count_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_count failed: unknown result";
}
sub multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_slice($keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_slice();
}

sub send_multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_slice', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_multiget_slice_args();
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_multiget_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "multiget_slice failed: unknown result";
}
sub multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_count($keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_count();
}

sub send_multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_count', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_multiget_count_args();
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_multiget_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "multiget_count failed: unknown result";
}
sub get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

    $self->send_get_range_slices($column_parent, $predicate, $range, $consistency_level);
  return $self->recv_get_range_slices();
}

sub send_get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_range_slices', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_range_slices_args();
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{range} = $range;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_range_slices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_range_slices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    # perlcassa modification for better errors
    use Data::Dumper;
    print STDERR Dumper($result->{ire});
    # end perlcassa modification
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_range_slices failed: unknown result";
}
sub get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

    $self->send_get_paged_slice($column_family, $range, $start_column, $consistency_level);
  return $self->recv_get_paged_slice();
}

sub send_get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_paged_slice', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_paged_slice_args();
  $args->{column_family} = $column_family;
  $args->{range} = $range;
  $args->{start_column} = $start_column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_paged_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_paged_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_paged_slice failed: unknown result";
}
sub get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

    $self->send_get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
  return $self->recv_get_indexed_slices();
}

sub send_get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_indexed_slices', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_indexed_slices_args();
  $args->{column_parent} = $column_parent;
  $args->{index_clause} = $index_clause;
  $args->{column_predicate} = $column_predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_indexed_slices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_indexed_slices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_indexed_slices failed: unknown result";
}
sub insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

    $self->send_insert($key, $column_parent, $column, $consistency_level);
  $self->recv_insert();
}

sub send_insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('insert', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_insert_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{column} = $column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

    $self->send_add($key, $column_parent, $column, $consistency_level);
  $self->recv_add();
}

sub send_add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('add', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_add_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{column} = $column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_add_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

    $self->send_remove($key, $column_path, $timestamp, $consistency_level);
  $self->recv_remove();
}

sub send_remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_remove_args();
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{timestamp} = $timestamp;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_remove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

    $self->send_remove_counter($key, $path, $consistency_level);
  $self->recv_remove_counter();
}

sub send_remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove_counter', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_remove_counter_args();
  $args->{key} = $key;
  $args->{path} = $path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove_counter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_remove_counter_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

    $self->send_batch_mutate($mutation_map, $consistency_level);
  $self->recv_batch_mutate();
}

sub send_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('batch_mutate', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_batch_mutate_args();
  $args->{mutation_map} = $mutation_map;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_batch_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_batch_mutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub atomic_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

    $self->send_atomic_batch_mutate($mutation_map, $consistency_level);
  $self->recv_atomic_batch_mutate();
}

sub send_atomic_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('atomic_batch_mutate', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_atomic_batch_mutate_args();
  $args->{mutation_map} = $mutation_map;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_atomic_batch_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_atomic_batch_mutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub truncate{
  my $self = shift;
  my $cfname = shift;

    $self->send_truncate($cfname);
  $self->recv_truncate();
}

sub send_truncate{
  my $self = shift;
  my $cfname = shift;

  $self->{output}->writeMessageBegin('truncate', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_truncate_args();
  $args->{cfname} = $cfname;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_truncate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_truncate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub describe_schema_versions{
  my $self = shift;

    $self->send_describe_schema_versions();
  return $self->recv_describe_schema_versions();
}

sub send_describe_schema_versions{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_schema_versions', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_schema_versions_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_schema_versions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_schema_versions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_schema_versions failed: unknown result";
}
sub describe_keyspaces{
  my $self = shift;

    $self->send_describe_keyspaces();
  return $self->recv_describe_keyspaces();
}

sub send_describe_keyspaces{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_keyspaces', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_keyspaces_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspaces{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_keyspaces_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_keyspaces failed: unknown result";
}
sub describe_cluster_name{
  my $self = shift;

    $self->send_describe_cluster_name();
  return $self->recv_describe_cluster_name();
}

sub send_describe_cluster_name{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_cluster_name', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_cluster_name_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_cluster_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_cluster_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_cluster_name failed: unknown result";
}
sub describe_version{
  my $self = shift;

    $self->send_describe_version();
  return $self->recv_describe_version();
}

sub send_describe_version{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_version', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_version_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_version{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_version_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_version failed: unknown result";
}
sub describe_ring{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_ring($keyspace);
  return $self->recv_describe_ring();
}

sub send_describe_ring{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_ring', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_ring_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_ring{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_ring_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_ring failed: unknown result";
}
sub describe_token_map{
  my $self = shift;

    $self->send_describe_token_map();
  return $self->recv_describe_token_map();
}

sub send_describe_token_map{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_token_map', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_token_map_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_token_map{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_token_map_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_token_map failed: unknown result";
}
sub describe_partitioner{
  my $self = shift;

    $self->send_describe_partitioner();
  return $self->recv_describe_partitioner();
}

sub send_describe_partitioner{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_partitioner', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_partitioner_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_partitioner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_partitioner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_partitioner failed: unknown result";
}
sub describe_snitch{
  my $self = shift;

    $self->send_describe_snitch();
  return $self->recv_describe_snitch();
}

sub send_describe_snitch{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_snitch', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_snitch_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_snitch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_snitch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_snitch failed: unknown result";
}
sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_keyspace($keyspace);
  return $self->recv_describe_keyspace();
}

sub send_describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_keyspace failed: unknown result";
}
sub describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

    $self->send_describe_splits($cfName, $start_token, $end_token, $keys_per_split);
  return $self->recv_describe_splits();
}

sub send_describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  $self->{output}->writeMessageBegin('describe_splits', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_splits_args();
  $args->{cfName} = $cfName;
  $args->{start_token} = $start_token;
  $args->{end_token} = $end_token;
  $args->{keys_per_split} = $keys_per_split;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_splits_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_splits failed: unknown result";
}
sub trace_next_query{
  my $self = shift;

    $self->send_trace_next_query();
  return $self->recv_trace_next_query();
}

sub send_trace_next_query{
  my $self = shift;

  $self->{output}->writeMessageBegin('trace_next_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_trace_next_query_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_trace_next_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_trace_next_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "trace_next_query failed: unknown result";
}
sub describe_splits_ex{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

    $self->send_describe_splits_ex($cfName, $start_token, $end_token, $keys_per_split);
  return $self->recv_describe_splits_ex();
}

sub send_describe_splits_ex{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  $self->{output}->writeMessageBegin('describe_splits_ex', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_splits_ex_args();
  $args->{cfName} = $cfName;
  $args->{start_token} = $start_token;
  $args->{end_token} = $end_token;
  $args->{keys_per_split} = $keys_per_split;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_splits_ex{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_splits_ex_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_splits_ex failed: unknown result";
}
sub system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

    $self->send_system_add_column_family($cf_def);
  return $self->recv_system_add_column_family();
}

sub send_system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

  $self->{output}->writeMessageBegin('system_add_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_add_column_family_args();
  $args->{cf_def} = $cf_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_add_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_add_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_add_column_family failed: unknown result";
}
sub system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

    $self->send_system_drop_column_family($column_family);
  return $self->recv_system_drop_column_family();
}

sub send_system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

  $self->{output}->writeMessageBegin('system_drop_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_drop_column_family_args();
  $args->{column_family} = $column_family;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_drop_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_drop_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_drop_column_family failed: unknown result";
}
sub system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

    $self->send_system_add_keyspace($ks_def);
  return $self->recv_system_add_keyspace();
}

sub send_system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

  $self->{output}->writeMessageBegin('system_add_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_add_keyspace_args();
  $args->{ks_def} = $ks_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_add_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_add_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_add_keyspace failed: unknown result";
}
sub system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_system_drop_keyspace($keyspace);
  return $self->recv_system_drop_keyspace();
}

sub send_system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('system_drop_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_drop_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_drop_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_drop_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_drop_keyspace failed: unknown result";
}
sub system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

    $self->send_system_update_keyspace($ks_def);
  return $self->recv_system_update_keyspace();
}

sub send_system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

  $self->{output}->writeMessageBegin('system_update_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_update_keyspace_args();
  $args->{ks_def} = $ks_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_update_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_update_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_update_keyspace failed: unknown result";
}
sub system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

    $self->send_system_update_column_family($cf_def);
  return $self->recv_system_update_column_family();
}

sub send_system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

  $self->{output}->writeMessageBegin('system_update_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_update_column_family_args();
  $args->{cf_def} = $cf_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_update_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_update_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_update_column_family failed: unknown result";
}
sub execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_execute_cql_query($query, $compression);
  return $self->recv_execute_cql_query();
}

sub send_execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('execute_cql_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_execute_cql_query_args();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_execute_cql_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_cql_query failed: unknown result";
}
sub execute_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;
  my $consistency = shift;

    $self->send_execute_cql3_query($query, $compression, $consistency);
  return $self->recv_execute_cql3_query();
}

sub send_execute_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;
  my $consistency = shift;

  $self->{output}->writeMessageBegin('execute_cql3_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_execute_cql3_query_args();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->{consistency} = $consistency;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_cql3_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_execute_cql3_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_cql3_query failed: unknown result";
}
sub prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_prepare_cql_query($query, $compression);
  return $self->recv_prepare_cql_query();
}

sub send_prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('prepare_cql_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_prepare_cql_query_args();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_prepare_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_prepare_cql_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "prepare_cql_query failed: unknown result";
}
sub prepare_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_prepare_cql3_query($query, $compression);
  return $self->recv_prepare_cql3_query();
}

sub send_prepare_cql3_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('prepare_cql3_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_prepare_cql3_query_args();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_prepare_cql3_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_prepare_cql3_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "prepare_cql3_query failed: unknown result";
}
sub execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

    $self->send_execute_prepared_cql_query($itemId, $values);
  return $self->recv_execute_prepared_cql_query();
}

sub send_execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

  $self->{output}->writeMessageBegin('execute_prepared_cql_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_execute_prepared_cql_query_args();
  $args->{itemId} = $itemId;
  $args->{values} = $values;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_prepared_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_execute_prepared_cql_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_prepared_cql_query failed: unknown result";
}
sub execute_prepared_cql3_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;
  my $consistency = shift;

    $self->send_execute_prepared_cql3_query($itemId, $values, $consistency);
  return $self->recv_execute_prepared_cql3_query();
}

sub send_execute_prepared_cql3_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;
  my $consistency = shift;

  $self->{output}->writeMessageBegin('execute_prepared_cql3_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_execute_prepared_cql3_query_args();
  $args->{itemId} = $itemId;
  $args->{values} = $values;
  $args->{consistency} = $consistency;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_prepared_cql3_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_execute_prepared_cql3_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_prepared_cql3_query failed: unknown result";
}
sub set_cql_version{
  my $self = shift;
  my $version = shift;

    $self->send_set_cql_version($version);
  $self->recv_set_cql_version();
}

sub send_set_cql_version{
  my $self = shift;
  my $version = shift;

  $self->{output}->writeMessageBegin('set_cql_version', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_set_cql_version_args();
  $args->{version} = $version;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cql_version{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_set_cql_version_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  return;
}
package Cassandra::CassandraProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_login {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_login_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_login_result();
    eval {
      $self->{handler}->login($args->auth_request);
    }; if( UNIVERSAL::isa($@,'Cassandra::AuthenticationException') ){ 
      $result->{authnx} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::AuthorizationException') ){ 
      $result->{authzx} = $@;
    }
    $output->writeMessageBegin('login', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_set_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_set_keyspace_result();
    eval {
      $self->{handler}->set_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('set_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_result();
    eval {
      $result->{success} = $self->{handler}->get($args->key, $args->column_path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_slice_result();
    eval {
      $result->{success} = $self->{handler}->get_slice($args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_slice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_count_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_count_result();
    eval {
      $result->{success} = $self->{handler}->get_count($args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_count', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_multiget_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_multiget_slice_result();
    eval {
      $result->{success} = $self->{handler}->multiget_slice($args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('multiget_slice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_multiget_count_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_multiget_count_result();
    eval {
      $result->{success} = $self->{handler}->multiget_count($args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('multiget_count', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_range_slices {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_range_slices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_range_slices_result();
    eval {
      $result->{success} = $self->{handler}->get_range_slices($args->column_parent, $args->predicate, $args->range, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_range_slices', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_paged_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_paged_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_paged_slice_result();
    eval {
      $result->{success} = $self->{handler}->get_paged_slice($args->column_family, $args->range, $args->start_column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_paged_slice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_indexed_slices {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_indexed_slices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_indexed_slices_result();
    eval {
      $result->{success} = $self->{handler}->get_indexed_slices($args->column_parent, $args->index_clause, $args->column_predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_indexed_slices', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_insert {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_insert_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_insert_result();
    eval {
      $self->{handler}->insert($args->key, $args->column_parent, $args->column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('insert', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_add_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_add_result();
    eval {
      $self->{handler}->add($args->key, $args->column_parent, $args->column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('add', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_remove_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_remove_result();
    eval {
      $self->{handler}->remove($args->key, $args->column_path, $args->timestamp, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('remove', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove_counter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_remove_counter_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_remove_counter_result();
    eval {
      $self->{handler}->remove_counter($args->key, $args->path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('remove_counter', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_batch_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_batch_mutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_batch_mutate_result();
    eval {
      $self->{handler}->batch_mutate($args->mutation_map, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('batch_mutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_atomic_batch_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_atomic_batch_mutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_atomic_batch_mutate_result();
    eval {
      $self->{handler}->atomic_batch_mutate($args->mutation_map, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('atomic_batch_mutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_truncate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_truncate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_truncate_result();
    eval {
      $self->{handler}->truncate($args->cfname);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('truncate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_schema_versions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_schema_versions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_schema_versions_result();
    eval {
      $result->{success} = $self->{handler}->describe_schema_versions();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_schema_versions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspaces {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_keyspaces_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_keyspaces_result();
    eval {
      $result->{success} = $self->{handler}->describe_keyspaces();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_keyspaces', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_cluster_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_cluster_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_cluster_name_result();
    $result->{success} = $self->{handler}->describe_cluster_name();
    $output->writeMessageBegin('describe_cluster_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_version {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_version_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_version_result();
    $result->{success} = $self->{handler}->describe_version();
    $output->writeMessageBegin('describe_version', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_ring {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_ring_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_ring_result();
    eval {
      $result->{success} = $self->{handler}->describe_ring($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_ring', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_token_map {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_token_map_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_token_map_result();
    eval {
      $result->{success} = $self->{handler}->describe_token_map();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_token_map', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_partitioner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_partitioner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_partitioner_result();
    $result->{success} = $self->{handler}->describe_partitioner();
    $output->writeMessageBegin('describe_partitioner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_snitch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_snitch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_snitch_result();
    $result->{success} = $self->{handler}->describe_snitch();
    $output->writeMessageBegin('describe_snitch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->describe_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_splits_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_splits_result();
    eval {
      $result->{success} = $self->{handler}->describe_splits($args->cfName, $args->start_token, $args->end_token, $args->keys_per_split);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_splits', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_trace_next_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_trace_next_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_trace_next_query_result();
    $result->{success} = $self->{handler}->trace_next_query();
    $output->writeMessageBegin('trace_next_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_splits_ex {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_splits_ex_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_splits_ex_result();
    eval {
      $result->{success} = $self->{handler}->describe_splits_ex($args->cfName, $args->start_token, $args->end_token, $args->keys_per_split);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_splits_ex', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_add_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_add_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_add_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_add_column_family($args->cf_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_add_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_drop_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_drop_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_drop_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_drop_column_family($args->column_family);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_drop_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_add_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_add_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_add_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_add_keyspace($args->ks_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_add_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_drop_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_drop_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_drop_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_drop_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_drop_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_update_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_update_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_update_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_update_keyspace($args->ks_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_update_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_update_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_update_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_update_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_update_column_family($args->cf_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_update_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_execute_cql_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_execute_cql_query_result();
    eval {
      $result->{success} = $self->{handler}->execute_cql_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('execute_cql_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_cql3_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_execute_cql3_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_execute_cql3_query_result();
    eval {
      $result->{success} = $self->{handler}->execute_cql3_query($args->query, $args->compression, $args->consistency);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('execute_cql3_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_prepare_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_prepare_cql_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_prepare_cql_query_result();
    eval {
      $result->{success} = $self->{handler}->prepare_cql_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('prepare_cql_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_prepare_cql3_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_prepare_cql3_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_prepare_cql3_query_result();
    eval {
      $result->{success} = $self->{handler}->prepare_cql3_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('prepare_cql3_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_prepared_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_execute_prepared_cql_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_execute_prepared_cql_query_result();
    eval {
      $result->{success} = $self->{handler}->execute_prepared_cql_query($args->itemId, $args->values);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('execute_prepared_cql_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_prepared_cql3_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_execute_prepared_cql3_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_execute_prepared_cql3_query_result();
    eval {
      $result->{success} = $self->{handler}->execute_prepared_cql3_query($args->itemId, $args->values, $args->consistency);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('execute_prepared_cql3_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cql_version {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_set_cql_version_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_set_cql_version_result();
    eval {
      $self->{handler}->set_cql_version($args->version);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('set_cql_version', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
