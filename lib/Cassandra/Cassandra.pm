#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Cassandra::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Cassandra::Cassandra_login_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_login_args->mk_accessors( qw( auth_request ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{auth_request} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{auth_request}) {
      $self->{auth_request} = $vals->{auth_request};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_login_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{auth_request} = new Cassandra::AuthenticationRequest();
        $xfer += $self->{auth_request}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_login_args');
  if (defined $self->{auth_request}) {
    $xfer += $output->writeFieldBegin('auth_request', TType::STRUCT, 1);
    $xfer += $self->{auth_request}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_login_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_login_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{authnx} = undef;
  $self->{authzx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{authnx}) {
      $self->{authnx} = $vals->{authnx};
    }
    if (defined $vals->{authzx}) {
      $self->{authzx} = $vals->{authzx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_login_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{authnx} = new Cassandra::AuthenticationException();
        $xfer += $self->{authnx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{authzx} = new Cassandra::AuthorizationException();
        $xfer += $self->{authzx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_login_result');
  if (defined $self->{authnx}) {
    $xfer += $output->writeFieldBegin('authnx', TType::STRUCT, 1);
    $xfer += $self->{authnx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{authzx}) {
    $xfer += $output->writeFieldBegin('authzx', TType::STRUCT, 2);
    $xfer += $self->{authzx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_keyspace_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_keyspace_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_args->mk_accessors( qw( key column_path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_path} = new Cassandra::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', TType::STRUCT, 2);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{nfe} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::ColumnOrSuperColumn();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{nfe} = new Cassandra::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', TType::STRUCT, 2);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 3);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 4);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_slice_args->mk_accessors( qw( key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size161 = 0;
          $self->{success} = [];
          my $_etype164 = 0;
          $xfer += $input->readListBegin(\$_etype164, \$_size161);
          for (my $_i165 = 0; $_i165 < $_size161; ++$_i165)
          {
            my $elem166 = undef;
            $elem166 = new Cassandra::ColumnOrSuperColumn();
            $xfer += $elem166->read($input);
            push(@{$self->{success}},$elem166);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter167 (@{$self->{success}}) 
        {
          $xfer += ${iter167}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_count_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_count_args->mk_accessors( qw( key column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_count_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_slice_args->mk_accessors( qw( keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size168 = 0;
          $self->{keys} = [];
          my $_etype171 = 0;
          $xfer += $input->readListBegin(\$_etype171, \$_size168);
          for (my $_i172 = 0; $_i172 < $_size168; ++$_i172)
          {
            my $elem173 = undef;
            $xfer += $input->readString(\$elem173);
            push(@{$self->{keys}},$elem173);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_args');
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter174 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter174);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size175 = 0;
          $self->{success} = {};
          my $_ktype176 = 0;
          my $_vtype177 = 0;
          $xfer += $input->readMapBegin(\$_ktype176, \$_vtype177, \$_size175);
          for (my $_i179 = 0; $_i179 < $_size175; ++$_i179)
          {
            my $key180 = '';
            my $val181 = [];
            $xfer += $input->readString(\$key180);
            {
              my $_size182 = 0;
              $val181 = [];
              my $_etype185 = 0;
              $xfer += $input->readListBegin(\$_etype185, \$_size182);
              for (my $_i186 = 0; $_i186 < $_size182; ++$_i186)
              {
                my $elem187 = undef;
                $elem187 = new Cassandra::ColumnOrSuperColumn();
                $xfer += $elem187->read($input);
                push(@{$val181},$elem187);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key180} = $val181;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter188,$viter189) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter188);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter189}}));
            {
              foreach my $iter190 (@{${viter189}}) 
              {
                $xfer += ${iter190}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_count_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_count_args->mk_accessors( qw( keys column_parent predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keys} = undef;
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keys}) {
      $self->{keys} = $vals->{keys};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_count_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size191 = 0;
          $self->{keys} = [];
          my $_etype194 = 0;
          $xfer += $input->readListBegin(\$_etype194, \$_size191);
          for (my $_i195 = 0; $_i195 < $_size191; ++$_i195)
          {
            my $elem196 = undef;
            $xfer += $input->readString(\$elem196);
            push(@{$self->{keys}},$elem196);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_count_args');
  if (defined $self->{keys}) {
    $xfer += $output->writeFieldBegin('keys', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{keys}}));
      {
        foreach my $iter197 (@{$self->{keys}}) 
        {
          $xfer += $output->writeString($iter197);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 3);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_multiget_count_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_multiget_count_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_multiget_count_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size198 = 0;
          $self->{success} = {};
          my $_ktype199 = 0;
          my $_vtype200 = 0;
          $xfer += $input->readMapBegin(\$_ktype199, \$_vtype200, \$_size198);
          for (my $_i202 = 0; $_i202 < $_size198; ++$_i202)
          {
            my $key203 = '';
            my $val204 = 0;
            $xfer += $input->readString(\$key203);
            $xfer += $input->readI32(\$val204);
            $self->{success}->{$key203} = $val204;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_multiget_count_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter205,$viter206) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter205);
          $xfer += $output->writeI32($viter206);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_range_slices_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_range_slices_args->mk_accessors( qw( column_parent predicate range consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_parent} = undef;
  $self->{predicate} = undef;
  $self->{range} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{predicate}) {
      $self->{predicate} = $vals->{predicate};
    }
    if (defined $vals->{range}) {
      $self->{range} = $vals->{range};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slices_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{range} = new Cassandra::KeyRange();
        $xfer += $self->{range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slices_args');
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 1);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{predicate}) {
    $xfer += $output->writeFieldBegin('predicate', TType::STRUCT, 2);
    $xfer += $self->{predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{range}) {
    $xfer += $output->writeFieldBegin('range', TType::STRUCT, 3);
    $xfer += $self->{range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_range_slices_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_range_slices_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_range_slices_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size207 = 0;
          $self->{success} = [];
          my $_etype210 = 0;
          $xfer += $input->readListBegin(\$_etype210, \$_size207);
          for (my $_i211 = 0; $_i211 < $_size207; ++$_i211)
          {
            my $elem212 = undef;
            $elem212 = new Cassandra::KeySlice();
            $xfer += $elem212->read($input);
            push(@{$self->{success}},$elem212);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_range_slices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter213 (@{$self->{success}}) 
        {
          $xfer += ${iter213}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_paged_slice_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_paged_slice_args->mk_accessors( qw( column_family range start_column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  $self->{range} = undef;
  $self->{start_column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
    if (defined $vals->{range}) {
      $self->{range} = $vals->{range};
    }
    if (defined $vals->{start_column}) {
      $self->{start_column} = $vals->{start_column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_paged_slice_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{range} = new Cassandra::KeyRange();
        $xfer += $self->{range}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_paged_slice_args');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{range}) {
    $xfer += $output->writeFieldBegin('range', TType::STRUCT, 2);
    $xfer += $self->{range}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_column}) {
    $xfer += $output->writeFieldBegin('start_column', TType::STRING, 3);
    $xfer += $output->writeString($self->{start_column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_paged_slice_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_paged_slice_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_paged_slice_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size214 = 0;
          $self->{success} = [];
          my $_etype217 = 0;
          $xfer += $input->readListBegin(\$_etype217, \$_size214);
          for (my $_i218 = 0; $_i218 < $_size214; ++$_i218)
          {
            my $elem219 = undef;
            $elem219 = new Cassandra::KeySlice();
            $xfer += $elem219->read($input);
            push(@{$self->{success}},$elem219);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_paged_slice_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter220 (@{$self->{success}}) 
        {
          $xfer += ${iter220}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_indexed_slices_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_indexed_slices_args->mk_accessors( qw( column_parent index_clause column_predicate consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_parent} = undef;
  $self->{index_clause} = undef;
  $self->{column_predicate} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{index_clause}) {
      $self->{index_clause} = $vals->{index_clause};
    }
    if (defined $vals->{column_predicate}) {
      $self->{column_predicate} = $vals->{column_predicate};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_indexed_slices_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{index_clause} = new Cassandra::IndexClause();
        $xfer += $self->{index_clause}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_predicate} = new Cassandra::SlicePredicate();
        $xfer += $self->{column_predicate}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_indexed_slices_args');
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 1);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_clause}) {
    $xfer += $output->writeFieldBegin('index_clause', TType::STRUCT, 2);
    $xfer += $self->{index_clause}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_predicate}) {
    $xfer += $output->writeFieldBegin('column_predicate', TType::STRUCT, 3);
    $xfer += $self->{column_predicate}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_get_indexed_slices_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_get_indexed_slices_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_get_indexed_slices_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size221 = 0;
          $self->{success} = [];
          my $_etype224 = 0;
          $xfer += $input->readListBegin(\$_etype224, \$_size221);
          for (my $_i225 = 0; $_i225 < $_size221; ++$_i225)
          {
            my $elem226 = undef;
            $elem226 = new Cassandra::KeySlice();
            $xfer += $elem226->read($input);
            push(@{$self->{success}},$elem226);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_get_indexed_slices_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter227 (@{$self->{success}}) 
        {
          $xfer += ${iter227}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_insert_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_insert_args->mk_accessors( qw( key column_parent column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::Column();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 3);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_insert_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_insert_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_insert_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_insert_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_add_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_add_args->mk_accessors( qw( key column_parent column consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_parent} = undef;
  $self->{column} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_parent}) {
      $self->{column_parent} = $vals->{column_parent};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_add_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_parent} = new Cassandra::ColumnParent();
        $xfer += $self->{column_parent}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column} = new Cassandra::CounterColumn();
        $xfer += $self->{column}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_add_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_parent}) {
    $xfer += $output->writeFieldBegin('column_parent', TType::STRUCT, 2);
    $xfer += $self->{column_parent}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRUCT, 3);
    $xfer += $self->{column}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_add_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_add_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_add_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_add_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_args->mk_accessors( qw( key column_path timestamp consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{column_path} = undef;
  $self->{timestamp} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{column_path}) {
      $self->{column_path} = $vals->{column_path};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{column_path} = new Cassandra::ColumnPath();
        $xfer += $self->{column_path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column_path}) {
    $xfer += $output->writeFieldBegin('column_path', TType::STRUCT, 2);
    $xfer += $self->{column_path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 4);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_counter_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_counter_args->mk_accessors( qw( key path consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{key} = undef;
  $self->{path} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{key}) {
      $self->{key} = $vals->{key};
    }
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_counter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{key});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Cassandra::ColumnPath();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_counter_args');
  if (defined $self->{key}) {
    $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
    $xfer += $output->writeString($self->{key});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 2);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 3);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_remove_counter_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_remove_counter_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_remove_counter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_remove_counter_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_batch_mutate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_batch_mutate_args->mk_accessors( qw( mutation_map consistency_level ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation_map} = undef;
  $self->{consistency_level} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation_map}) {
      $self->{mutation_map} = $vals->{mutation_map};
    }
    if (defined $vals->{consistency_level}) {
      $self->{consistency_level} = $vals->{consistency_level};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size228 = 0;
          $self->{mutation_map} = {};
          my $_ktype229 = 0;
          my $_vtype230 = 0;
          $xfer += $input->readMapBegin(\$_ktype229, \$_vtype230, \$_size228);
          for (my $_i232 = 0; $_i232 < $_size228; ++$_i232)
          {
            my $key233 = '';
            my $val234 = [];
            $xfer += $input->readString(\$key233);
            {
              my $_size235 = 0;
              $val234 = {};
              my $_ktype236 = 0;
              my $_vtype237 = 0;
              $xfer += $input->readMapBegin(\$_ktype236, \$_vtype237, \$_size235);
              for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
              {
                my $key240 = '';
                my $val241 = [];
                $xfer += $input->readString(\$key240);
                {
                  my $_size242 = 0;
                  $val241 = [];
                  my $_etype245 = 0;
                  $xfer += $input->readListBegin(\$_etype245, \$_size242);
                  for (my $_i246 = 0; $_i246 < $_size242; ++$_i246)
                  {
                    my $elem247 = undef;
                    $elem247 = new Cassandra::Mutation();
                    $xfer += $elem247->read($input);
                    push(@{$val241},$elem247);
                  }
                  $xfer += $input->readListEnd();
                }
                $val234->{$key240} = $val241;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{mutation_map}->{$key233} = $val234;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{consistency_level});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_mutate_args');
  if (defined $self->{mutation_map}) {
    $xfer += $output->writeFieldBegin('mutation_map', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{mutation_map}}));
      {
        while( my ($kiter248,$viter249) = each %{$self->{mutation_map}}) 
        {
          $xfer += $output->writeString($kiter248);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{${viter249}}));
            {
              while( my ($kiter250,$viter251) = each %{${viter249}}) 
              {
                $xfer += $output->writeString($kiter250);
                {
                  $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter251}}));
                  {
                    foreach my $iter252 (@{${viter251}}) 
                    {
                      $xfer += ${iter252}->write($output);
                    }
                  }
                  $xfer += $output->writeListEnd();
                }
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{consistency_level}) {
    $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
    $xfer += $output->writeI32($self->{consistency_level});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_batch_mutate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_batch_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_batch_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_batch_mutate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_truncate_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_truncate_args->mk_accessors( qw( cfname ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfname} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfname}) {
      $self->{cfname} = $vals->{cfname};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_truncate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cfname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_truncate_args');
  if (defined $self->{cfname}) {
    $xfer += $output->writeFieldBegin('cfname', TType::STRING, 1);
    $xfer += $output->writeString($self->{cfname});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_truncate_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_truncate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_truncate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_truncate_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_schema_versions_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_schema_versions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_schema_versions_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_schema_versions_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_schema_versions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_schema_versions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size253 = 0;
          $self->{success} = {};
          my $_ktype254 = 0;
          my $_vtype255 = 0;
          $xfer += $input->readMapBegin(\$_ktype254, \$_vtype255, \$_size253);
          for (my $_i257 = 0; $_i257 < $_size253; ++$_i257)
          {
            my $key258 = '';
            my $val259 = [];
            $xfer += $input->readString(\$key258);
            {
              my $_size260 = 0;
              $val259 = [];
              my $_etype263 = 0;
              $xfer += $input->readListBegin(\$_etype263, \$_size260);
              for (my $_i264 = 0; $_i264 < $_size260; ++$_i264)
              {
                my $elem265 = undef;
                $xfer += $input->readString(\$elem265);
                push(@{$val259},$elem265);
              }
              $xfer += $input->readListEnd();
            }
            $self->{success}->{$key258} = $val259;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_schema_versions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter266,$viter267) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter266);
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${viter267}}));
            {
              foreach my $iter268 (@{${viter267}}) 
              {
                $xfer += $output->writeString($iter268);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspaces_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspaces_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspaces_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspaces_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspaces_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspaces_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size269 = 0;
          $self->{success} = [];
          my $_etype272 = 0;
          $xfer += $input->readListBegin(\$_etype272, \$_size269);
          for (my $_i273 = 0; $_i273 < $_size269; ++$_i273)
          {
            my $elem274 = undef;
            $elem274 = new Cassandra::KsDef();
            $xfer += $elem274->read($input);
            push(@{$self->{success}},$elem274);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspaces_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter275 (@{$self->{success}}) 
        {
          $xfer += ${iter275}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_cluster_name_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_cluster_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_cluster_name_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_cluster_name_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_cluster_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_cluster_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_cluster_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_version_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_version_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_version_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_version_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_version_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_version_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_version_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_ring_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_ring_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_ring_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_ring_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_ring_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_ring_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_ring_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size276 = 0;
          $self->{success} = [];
          my $_etype279 = 0;
          $xfer += $input->readListBegin(\$_etype279, \$_size276);
          for (my $_i280 = 0; $_i280 < $_size276; ++$_i280)
          {
            my $elem281 = undef;
            $elem281 = new Cassandra::TokenRange();
            $xfer += $elem281->read($input);
            push(@{$self->{success}},$elem281);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_ring_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter282 (@{$self->{success}}) 
        {
          $xfer += ${iter282}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_partitioner_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_partitioner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_partitioner_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_partitioner_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_partitioner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_partitioner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_partitioner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_snitch_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_snitch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_snitch_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_snitch_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_snitch_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_snitch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_snitch_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{nfe} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nfe}) {
      $self->{nfe} = $vals->{nfe};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::KsDef();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{nfe} = new Cassandra::NotFoundException();
        $xfer += $self->{nfe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nfe}) {
    $xfer += $output->writeFieldBegin('nfe', TType::STRUCT, 1);
    $xfer += $self->{nfe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 2);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_args->mk_accessors( qw( cfName start_token end_token keys_per_split ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cfName} = undef;
  $self->{start_token} = undef;
  $self->{end_token} = undef;
  $self->{keys_per_split} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cfName}) {
      $self->{cfName} = $vals->{cfName};
    }
    if (defined $vals->{start_token}) {
      $self->{start_token} = $vals->{start_token};
    }
    if (defined $vals->{end_token}) {
      $self->{end_token} = $vals->{end_token};
    }
    if (defined $vals->{keys_per_split}) {
      $self->{keys_per_split} = $vals->{keys_per_split};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cfName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{start_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{end_token});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{keys_per_split});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_args');
  if (defined $self->{cfName}) {
    $xfer += $output->writeFieldBegin('cfName', TType::STRING, 1);
    $xfer += $output->writeString($self->{cfName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start_token}) {
    $xfer += $output->writeFieldBegin('start_token', TType::STRING, 2);
    $xfer += $output->writeString($self->{start_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{end_token}) {
    $xfer += $output->writeFieldBegin('end_token', TType::STRING, 3);
    $xfer += $output->writeString($self->{end_token});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{keys_per_split}) {
    $xfer += $output->writeFieldBegin('keys_per_split', TType::I32, 4);
    $xfer += $output->writeI32($self->{keys_per_split});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_describe_splits_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_describe_splits_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_describe_splits_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size283 = 0;
          $self->{success} = [];
          my $_etype286 = 0;
          $xfer += $input->readListBegin(\$_etype286, \$_size283);
          for (my $_i287 = 0; $_i287 < $_size283; ++$_i287)
          {
            my $elem288 = undef;
            $xfer += $input->readString(\$elem288);
            push(@{$self->{success}},$elem288);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_describe_splits_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter289 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter289);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_column_family_args->mk_accessors( qw( cf_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cf_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cf_def}) {
      $self->{cf_def} = $vals->{cf_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cf_def} = new Cassandra::CfDef();
        $xfer += $self->{cf_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_column_family_args');
  if (defined $self->{cf_def}) {
    $xfer += $output->writeFieldBegin('cf_def', TType::STRUCT, 1);
    $xfer += $self->{cf_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_column_family_args->mk_accessors( qw( column_family ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{column_family} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{column_family}) {
      $self->{column_family} = $vals->{column_family};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column_family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_column_family_args');
  if (defined $self->{column_family}) {
    $xfer += $output->writeFieldBegin('column_family', TType::STRING, 1);
    $xfer += $output->writeString($self->{column_family});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_keyspace_args->mk_accessors( qw( ks_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ks_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ks_def}) {
      $self->{ks_def} = $vals->{ks_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ks_def} = new Cassandra::KsDef();
        $xfer += $self->{ks_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_keyspace_args');
  if (defined $self->{ks_def}) {
    $xfer += $output->writeFieldBegin('ks_def', TType::STRUCT, 1);
    $xfer += $self->{ks_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_add_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_add_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_add_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_add_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_keyspace_args->mk_accessors( qw( keyspace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{keyspace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{keyspace}) {
      $self->{keyspace} = $vals->{keyspace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{keyspace});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_keyspace_args');
  if (defined $self->{keyspace}) {
    $xfer += $output->writeFieldBegin('keyspace', TType::STRING, 1);
    $xfer += $output->writeString($self->{keyspace});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_drop_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_drop_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_drop_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_drop_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_keyspace_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_keyspace_args->mk_accessors( qw( ks_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ks_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ks_def}) {
      $self->{ks_def} = $vals->{ks_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_keyspace_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ks_def} = new Cassandra::KsDef();
        $xfer += $self->{ks_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_keyspace_args');
  if (defined $self->{ks_def}) {
    $xfer += $output->writeFieldBegin('ks_def', TType::STRUCT, 1);
    $xfer += $self->{ks_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_keyspace_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_keyspace_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_keyspace_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_keyspace_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_column_family_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_column_family_args->mk_accessors( qw( cf_def ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cf_def} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cf_def}) {
      $self->{cf_def} = $vals->{cf_def};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_column_family_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{cf_def} = new Cassandra::CfDef();
        $xfer += $self->{cf_def}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_column_family_args');
  if (defined $self->{cf_def}) {
    $xfer += $output->writeFieldBegin('cf_def', TType::STRUCT, 1);
    $xfer += $self->{cf_def}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_system_update_column_family_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_system_update_column_family_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_system_update_column_family_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_system_update_column_family_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 2);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql_query_args->mk_accessors( qw( query compression ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{compression} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{compression}) {
      $self->{compression} = $vals->{compression};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compression});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql_query_args');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compression}) {
    $xfer += $output->writeFieldBegin('compression', TType::I32, 2);
    $xfer += $output->writeI32($self->{compression});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_prepare_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_prepare_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_prepare_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlPreparedResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_prepare_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql_query_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql_query_args->mk_accessors( qw( itemId values ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{itemId} = undef;
  $self->{values} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{itemId}) {
      $self->{itemId} = $vals->{itemId};
    }
    if (defined $vals->{values}) {
      $self->{values} = $vals->{values};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{itemId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size290 = 0;
          $self->{values} = [];
          my $_etype293 = 0;
          $xfer += $input->readListBegin(\$_etype293, \$_size290);
          for (my $_i294 = 0; $_i294 < $_size290; ++$_i294)
          {
            my $elem295 = undef;
            $xfer += $input->readString(\$elem295);
            push(@{$self->{values}},$elem295);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql_query_args');
  if (defined $self->{itemId}) {
    $xfer += $output->writeFieldBegin('itemId', TType::I32, 1);
    $xfer += $output->writeI32($self->{itemId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{values}) {
    $xfer += $output->writeFieldBegin('values', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{values}}));
      {
        foreach my $iter296 (@{$self->{values}}) 
        {
          $xfer += $output->writeString($iter296);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_execute_prepared_cql_query_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_execute_prepared_cql_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ire} = undef;
  $self->{ue} = undef;
  $self->{te} = undef;
  $self->{sde} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
    if (defined $vals->{te}) {
      $self->{te} = $vals->{te};
    }
    if (defined $vals->{sde}) {
      $self->{sde} = $vals->{sde};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_execute_prepared_cql_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Cassandra::CqlResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new Cassandra::UnavailableException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{te} = new Cassandra::TimedOutException();
        $xfer += $self->{te}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sde} = new Cassandra::SchemaDisagreementException();
        $xfer += $self->{sde}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_execute_prepared_cql_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{te}) {
    $xfer += $output->writeFieldBegin('te', TType::STRUCT, 3);
    $xfer += $self->{te}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sde}) {
    $xfer += $output->writeFieldBegin('sde', TType::STRUCT, 4);
    $xfer += $self->{sde}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_cql_version_args;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_cql_version_args->mk_accessors( qw( version ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{version} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_cql_version_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_cql_version_args');
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::STRING, 1);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::Cassandra_set_cql_version_result;
use base qw(Class::Accessor);
Cassandra::Cassandra_set_cql_version_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ire} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ire}) {
      $self->{ire} = $vals->{ire};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Cassandra_set_cql_version_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ire} = new Cassandra::InvalidRequestException();
        $xfer += $self->{ire}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Cassandra_set_cql_version_result');
  if (defined $self->{ire}) {
    $xfer += $output->writeFieldBegin('ire', TType::STRUCT, 1);
    $xfer += $self->{ire}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Cassandra::CassandraIf;

use strict;


sub login{
  my $self = shift;
  my $auth_request = shift;

  die 'implement interface';
}

sub set_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  die 'implement interface';
}

sub truncate{
  my $self = shift;
  my $cfname = shift;

  die 'implement interface';
}

sub describe_schema_versions{
  my $self = shift;

  die 'implement interface';
}

sub describe_keyspaces{
  my $self = shift;

  die 'implement interface';
}

sub describe_cluster_name{
  my $self = shift;

  die 'implement interface';
}

sub describe_version{
  my $self = shift;

  die 'implement interface';
}

sub describe_ring{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_partitioner{
  my $self = shift;

  die 'implement interface';
}

sub describe_snitch{
  my $self = shift;

  die 'implement interface';
}

sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  die 'implement interface';
}

sub system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

  die 'implement interface';
}

sub system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

  die 'implement interface';
}

sub system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

  die 'implement interface';
}

sub system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

  die 'implement interface';
}

sub system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

  die 'implement interface';
}

sub system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

  die 'implement interface';
}

sub execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

sub prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  die 'implement interface';
}

sub execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

  die 'implement interface';
}

sub set_cql_version{
  my $self = shift;
  my $version = shift;

  die 'implement interface';
}

package Cassandra::CassandraRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub login{
  my ($self, $request) = @_;

  my $auth_request = ($request->{'auth_request'}) ? $request->{'auth_request'} : undef;
  return $self->{impl}->login($auth_request);
}

sub set_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->set_keyspace($keyspace);
}

sub get{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get($key, $column_path, $consistency_level);
}

sub get_slice{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_slice($key, $column_parent, $predicate, $consistency_level);
}

sub get_count{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_count($key, $column_parent, $predicate, $consistency_level);
}

sub multiget_slice{
  my ($self, $request) = @_;

  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_slice($keys, $column_parent, $predicate, $consistency_level);
}

sub multiget_count{
  my ($self, $request) = @_;

  my $keys = ($request->{'keys'}) ? $request->{'keys'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->multiget_count($keys, $column_parent, $predicate, $consistency_level);
}

sub get_range_slices{
  my ($self, $request) = @_;

  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $predicate = ($request->{'predicate'}) ? $request->{'predicate'} : undef;
  my $range = ($request->{'range'}) ? $request->{'range'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_range_slices($column_parent, $predicate, $range, $consistency_level);
}

sub get_paged_slice{
  my ($self, $request) = @_;

  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  my $range = ($request->{'range'}) ? $request->{'range'} : undef;
  my $start_column = ($request->{'start_column'}) ? $request->{'start_column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_paged_slice($column_family, $range, $start_column, $consistency_level);
}

sub get_indexed_slices{
  my ($self, $request) = @_;

  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $index_clause = ($request->{'index_clause'}) ? $request->{'index_clause'} : undef;
  my $column_predicate = ($request->{'column_predicate'}) ? $request->{'column_predicate'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
}

sub insert{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->insert($key, $column_parent, $column, $consistency_level);
}

sub add{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_parent = ($request->{'column_parent'}) ? $request->{'column_parent'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->add($key, $column_parent, $column, $consistency_level);
}

sub remove{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $column_path = ($request->{'column_path'}) ? $request->{'column_path'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove($key, $column_path, $timestamp, $consistency_level);
}

sub remove_counter{
  my ($self, $request) = @_;

  my $key = ($request->{'key'}) ? $request->{'key'} : undef;
  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->remove_counter($key, $path, $consistency_level);
}

sub batch_mutate{
  my ($self, $request) = @_;

  my $mutation_map = ($request->{'mutation_map'}) ? $request->{'mutation_map'} : undef;
  my $consistency_level = ($request->{'consistency_level'}) ? $request->{'consistency_level'} : undef;
  return $self->{impl}->batch_mutate($mutation_map, $consistency_level);
}

sub truncate{
  my ($self, $request) = @_;

  my $cfname = ($request->{'cfname'}) ? $request->{'cfname'} : undef;
  return $self->{impl}->truncate($cfname);
}

sub describe_schema_versions{
  my ($self, $request) = @_;

  return $self->{impl}->describe_schema_versions();
}

sub describe_keyspaces{
  my ($self, $request) = @_;

  return $self->{impl}->describe_keyspaces();
}

sub describe_cluster_name{
  my ($self, $request) = @_;

  return $self->{impl}->describe_cluster_name();
}

sub describe_version{
  my ($self, $request) = @_;

  return $self->{impl}->describe_version();
}

sub describe_ring{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_ring($keyspace);
}

sub describe_partitioner{
  my ($self, $request) = @_;

  return $self->{impl}->describe_partitioner();
}

sub describe_snitch{
  my ($self, $request) = @_;

  return $self->{impl}->describe_snitch();
}

sub describe_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->describe_keyspace($keyspace);
}

sub describe_splits{
  my ($self, $request) = @_;

  my $cfName = ($request->{'cfName'}) ? $request->{'cfName'} : undef;
  my $start_token = ($request->{'start_token'}) ? $request->{'start_token'} : undef;
  my $end_token = ($request->{'end_token'}) ? $request->{'end_token'} : undef;
  my $keys_per_split = ($request->{'keys_per_split'}) ? $request->{'keys_per_split'} : undef;
  return $self->{impl}->describe_splits($cfName, $start_token, $end_token, $keys_per_split);
}

sub system_add_column_family{
  my ($self, $request) = @_;

  my $cf_def = ($request->{'cf_def'}) ? $request->{'cf_def'} : undef;
  return $self->{impl}->system_add_column_family($cf_def);
}

sub system_drop_column_family{
  my ($self, $request) = @_;

  my $column_family = ($request->{'column_family'}) ? $request->{'column_family'} : undef;
  return $self->{impl}->system_drop_column_family($column_family);
}

sub system_add_keyspace{
  my ($self, $request) = @_;

  my $ks_def = ($request->{'ks_def'}) ? $request->{'ks_def'} : undef;
  return $self->{impl}->system_add_keyspace($ks_def);
}

sub system_drop_keyspace{
  my ($self, $request) = @_;

  my $keyspace = ($request->{'keyspace'}) ? $request->{'keyspace'} : undef;
  return $self->{impl}->system_drop_keyspace($keyspace);
}

sub system_update_keyspace{
  my ($self, $request) = @_;

  my $ks_def = ($request->{'ks_def'}) ? $request->{'ks_def'} : undef;
  return $self->{impl}->system_update_keyspace($ks_def);
}

sub system_update_column_family{
  my ($self, $request) = @_;

  my $cf_def = ($request->{'cf_def'}) ? $request->{'cf_def'} : undef;
  return $self->{impl}->system_update_column_family($cf_def);
}

sub execute_cql_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->execute_cql_query($query, $compression);
}

sub prepare_cql_query{
  my ($self, $request) = @_;

  my $query = ($request->{'query'}) ? $request->{'query'} : undef;
  my $compression = ($request->{'compression'}) ? $request->{'compression'} : undef;
  return $self->{impl}->prepare_cql_query($query, $compression);
}

sub execute_prepared_cql_query{
  my ($self, $request) = @_;

  my $itemId = ($request->{'itemId'}) ? $request->{'itemId'} : undef;
  my $values = ($request->{'values'}) ? $request->{'values'} : undef;
  return $self->{impl}->execute_prepared_cql_query($itemId, $values);
}

sub set_cql_version{
  my ($self, $request) = @_;

  my $version = ($request->{'version'}) ? $request->{'version'} : undef;
  return $self->{impl}->set_cql_version($version);
}

package Cassandra::CassandraClient;


use base qw(Cassandra::CassandraIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub login{
  my $self = shift;
  my $auth_request = shift;

    $self->send_login($auth_request);
  $self->recv_login();
}

sub send_login{
  my $self = shift;
  my $auth_request = shift;

  $self->{output}->writeMessageBegin('login', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_login_args();
  $args->{auth_request} = $auth_request;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_login{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_login_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{authnx}) {
    die $result->{authnx};
  }
  if (defined $result->{authzx}) {
    die $result->{authzx};
  }
  return;
}
sub set_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_set_keyspace($keyspace);
  $self->recv_set_keyspace();
}

sub send_set_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('set_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_set_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_set_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  return;
}
sub get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

    $self->send_get($key, $column_path, $consistency_level);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_args();
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    # perlcassa modification for better errors
    use Data::Dumper;
    print Dumper($result->{ire});
    # end perlcassa modification

    die $result->{ire};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get failed: unknown result";
}
sub get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_slice($key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_slice();
}

sub send_get_slice{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_slice', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_slice_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_slice failed: unknown result";
}
sub get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_get_count($key, $column_parent, $predicate, $consistency_level);
  return $self->recv_get_count();
}

sub send_get_count{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_count', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_count_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_count failed: unknown result";
}
sub multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_slice($keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_slice();
}

sub send_multiget_slice{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_slice', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_multiget_slice_args();
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_multiget_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "multiget_slice failed: unknown result";
}
sub multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

    $self->send_multiget_count($keys, $column_parent, $predicate, $consistency_level);
  return $self->recv_multiget_count();
}

sub send_multiget_count{
  my $self = shift;
  my $keys = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('multiget_count', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_multiget_count_args();
  $args->{keys} = $keys;
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_multiget_count{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_multiget_count_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "multiget_count failed: unknown result";
}
sub get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

    $self->send_get_range_slices($column_parent, $predicate, $range, $consistency_level);
  return $self->recv_get_range_slices();
}

sub send_get_range_slices{
  my $self = shift;
  my $column_parent = shift;
  my $predicate = shift;
  my $range = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_range_slices', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_range_slices_args();
  $args->{column_parent} = $column_parent;
  $args->{predicate} = $predicate;
  $args->{range} = $range;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_range_slices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_range_slices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_range_slices failed: unknown result";
}
sub get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

    $self->send_get_paged_slice($column_family, $range, $start_column, $consistency_level);
  return $self->recv_get_paged_slice();
}

sub send_get_paged_slice{
  my $self = shift;
  my $column_family = shift;
  my $range = shift;
  my $start_column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_paged_slice', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_paged_slice_args();
  $args->{column_family} = $column_family;
  $args->{range} = $range;
  $args->{start_column} = $start_column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_paged_slice{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_paged_slice_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_paged_slice failed: unknown result";
}
sub get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

    $self->send_get_indexed_slices($column_parent, $index_clause, $column_predicate, $consistency_level);
  return $self->recv_get_indexed_slices();
}

sub send_get_indexed_slices{
  my $self = shift;
  my $column_parent = shift;
  my $index_clause = shift;
  my $column_predicate = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('get_indexed_slices', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_get_indexed_slices_args();
  $args->{column_parent} = $column_parent;
  $args->{index_clause} = $index_clause;
  $args->{column_predicate} = $column_predicate;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_indexed_slices{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_get_indexed_slices_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  die "get_indexed_slices failed: unknown result";
}
sub insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

    $self->send_insert($key, $column_parent, $column, $consistency_level);
  $self->recv_insert();
}

sub send_insert{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('insert', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_insert_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{column} = $column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_insert{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_insert_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

    $self->send_add($key, $column_parent, $column, $consistency_level);
  $self->recv_add();
}

sub send_add{
  my $self = shift;
  my $key = shift;
  my $column_parent = shift;
  my $column = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('add', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_add_args();
  $args->{key} = $key;
  $args->{column_parent} = $column_parent;
  $args->{column} = $column;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_add_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

    $self->send_remove($key, $column_path, $timestamp, $consistency_level);
  $self->recv_remove();
}

sub send_remove{
  my $self = shift;
  my $key = shift;
  my $column_path = shift;
  my $timestamp = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_remove_args();
  $args->{key} = $key;
  $args->{column_path} = $column_path;
  $args->{timestamp} = $timestamp;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_remove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

    $self->send_remove_counter($key, $path, $consistency_level);
  $self->recv_remove_counter();
}

sub send_remove_counter{
  my $self = shift;
  my $key = shift;
  my $path = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('remove_counter', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_remove_counter_args();
  $args->{key} = $key;
  $args->{path} = $path;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove_counter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_remove_counter_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

    $self->send_batch_mutate($mutation_map, $consistency_level);
  $self->recv_batch_mutate();
}

sub send_batch_mutate{
  my $self = shift;
  my $mutation_map = shift;
  my $consistency_level = shift;

  $self->{output}->writeMessageBegin('batch_mutate', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_batch_mutate_args();
  $args->{mutation_map} = $mutation_map;
  $args->{consistency_level} = $consistency_level;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_batch_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_batch_mutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub truncate{
  my $self = shift;
  my $cfname = shift;

    $self->send_truncate($cfname);
  $self->recv_truncate();
}

sub send_truncate{
  my $self = shift;
  my $cfname = shift;

  $self->{output}->writeMessageBegin('truncate', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_truncate_args();
  $args->{cfname} = $cfname;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_truncate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_truncate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  return;
}
sub describe_schema_versions{
  my $self = shift;

    $self->send_describe_schema_versions();
  return $self->recv_describe_schema_versions();
}

sub send_describe_schema_versions{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_schema_versions', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_schema_versions_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_schema_versions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_schema_versions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_schema_versions failed: unknown result";
}
sub describe_keyspaces{
  my $self = shift;

    $self->send_describe_keyspaces();
  return $self->recv_describe_keyspaces();
}

sub send_describe_keyspaces{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_keyspaces', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_keyspaces_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspaces{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_keyspaces_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_keyspaces failed: unknown result";
}
sub describe_cluster_name{
  my $self = shift;

    $self->send_describe_cluster_name();
  return $self->recv_describe_cluster_name();
}

sub send_describe_cluster_name{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_cluster_name', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_cluster_name_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_cluster_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_cluster_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_cluster_name failed: unknown result";
}
sub describe_version{
  my $self = shift;

    $self->send_describe_version();
  return $self->recv_describe_version();
}

sub send_describe_version{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_version', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_version_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_version{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_version_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_version failed: unknown result";
}
sub describe_ring{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_ring($keyspace);
  return $self->recv_describe_ring();
}

sub send_describe_ring{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_ring', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_ring_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_ring{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_ring_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_ring failed: unknown result";
}
sub describe_partitioner{
  my $self = shift;

    $self->send_describe_partitioner();
  return $self->recv_describe_partitioner();
}

sub send_describe_partitioner{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_partitioner', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_partitioner_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_partitioner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_partitioner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_partitioner failed: unknown result";
}
sub describe_snitch{
  my $self = shift;

    $self->send_describe_snitch();
  return $self->recv_describe_snitch();
}

sub send_describe_snitch{
  my $self = shift;

  $self->{output}->writeMessageBegin('describe_snitch', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_snitch_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_snitch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_snitch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "describe_snitch failed: unknown result";
}
sub describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_describe_keyspace($keyspace);
  return $self->recv_describe_keyspace();
}

sub send_describe_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('describe_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nfe}) {
    die $result->{nfe};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_keyspace failed: unknown result";
}
sub describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

    $self->send_describe_splits($cfName, $start_token, $end_token, $keys_per_split);
  return $self->recv_describe_splits();
}

sub send_describe_splits{
  my $self = shift;
  my $cfName = shift;
  my $start_token = shift;
  my $end_token = shift;
  my $keys_per_split = shift;

  $self->{output}->writeMessageBegin('describe_splits', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_describe_splits_args();
  $args->{cfName} = $cfName;
  $args->{start_token} = $start_token;
  $args->{end_token} = $end_token;
  $args->{keys_per_split} = $keys_per_split;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe_splits{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_describe_splits_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "describe_splits failed: unknown result";
}
sub system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

    $self->send_system_add_column_family($cf_def);
  return $self->recv_system_add_column_family();
}

sub send_system_add_column_family{
  my $self = shift;
  my $cf_def = shift;

  $self->{output}->writeMessageBegin('system_add_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_add_column_family_args();
  $args->{cf_def} = $cf_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_add_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_add_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_add_column_family failed: unknown result";
}
sub system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

    $self->send_system_drop_column_family($column_family);
  return $self->recv_system_drop_column_family();
}

sub send_system_drop_column_family{
  my $self = shift;
  my $column_family = shift;

  $self->{output}->writeMessageBegin('system_drop_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_drop_column_family_args();
  $args->{column_family} = $column_family;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_drop_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_drop_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_drop_column_family failed: unknown result";
}
sub system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

    $self->send_system_add_keyspace($ks_def);
  return $self->recv_system_add_keyspace();
}

sub send_system_add_keyspace{
  my $self = shift;
  my $ks_def = shift;

  $self->{output}->writeMessageBegin('system_add_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_add_keyspace_args();
  $args->{ks_def} = $ks_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_add_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_add_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_add_keyspace failed: unknown result";
}
sub system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

    $self->send_system_drop_keyspace($keyspace);
  return $self->recv_system_drop_keyspace();
}

sub send_system_drop_keyspace{
  my $self = shift;
  my $keyspace = shift;

  $self->{output}->writeMessageBegin('system_drop_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_drop_keyspace_args();
  $args->{keyspace} = $keyspace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_drop_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_drop_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_drop_keyspace failed: unknown result";
}
sub system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

    $self->send_system_update_keyspace($ks_def);
  return $self->recv_system_update_keyspace();
}

sub send_system_update_keyspace{
  my $self = shift;
  my $ks_def = shift;

  $self->{output}->writeMessageBegin('system_update_keyspace', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_update_keyspace_args();
  $args->{ks_def} = $ks_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_update_keyspace{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_update_keyspace_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_update_keyspace failed: unknown result";
}
sub system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

    $self->send_system_update_column_family($cf_def);
  return $self->recv_system_update_column_family();
}

sub send_system_update_column_family{
  my $self = shift;
  my $cf_def = shift;

  $self->{output}->writeMessageBegin('system_update_column_family', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_system_update_column_family_args();
  $args->{cf_def} = $cf_def;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_system_update_column_family{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_system_update_column_family_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "system_update_column_family failed: unknown result";
}
sub execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_execute_cql_query($query, $compression);
  return $self->recv_execute_cql_query();
}

sub send_execute_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('execute_cql_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_execute_cql_query_args();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_execute_cql_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_cql_query failed: unknown result";
}
sub prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

    $self->send_prepare_cql_query($query, $compression);
  return $self->recv_prepare_cql_query();
}

sub send_prepare_cql_query{
  my $self = shift;
  my $query = shift;
  my $compression = shift;

  $self->{output}->writeMessageBegin('prepare_cql_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_prepare_cql_query_args();
  $args->{query} = $query;
  $args->{compression} = $compression;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_prepare_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_prepare_cql_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  die "prepare_cql_query failed: unknown result";
}
sub execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

    $self->send_execute_prepared_cql_query($itemId, $values);
  return $self->recv_execute_prepared_cql_query();
}

sub send_execute_prepared_cql_query{
  my $self = shift;
  my $itemId = shift;
  my $values = shift;

  $self->{output}->writeMessageBegin('execute_prepared_cql_query', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_execute_prepared_cql_query_args();
  $args->{itemId} = $itemId;
  $args->{values} = $values;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_execute_prepared_cql_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_execute_prepared_cql_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ire}) {
    die $result->{ire};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  if (defined $result->{te}) {
    die $result->{te};
  }
  if (defined $result->{sde}) {
    die $result->{sde};
  }
  die "execute_prepared_cql_query failed: unknown result";
}
sub set_cql_version{
  my $self = shift;
  my $version = shift;

    $self->send_set_cql_version($version);
  $self->recv_set_cql_version();
}

sub send_set_cql_version{
  my $self = shift;
  my $version = shift;

  $self->{output}->writeMessageBegin('set_cql_version', TMessageType::CALL, $self->{seqid});
  my $args = new Cassandra::Cassandra_set_cql_version_args();
  $args->{version} = $version;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_set_cql_version{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Cassandra::Cassandra_set_cql_version_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ire}) {
    die $result->{ire};
  }
  return;
}
package Cassandra::CassandraProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_login {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_login_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_login_result();
    eval {
      $self->{handler}->login($args->auth_request);
    }; if( UNIVERSAL::isa($@,'Cassandra::AuthenticationException') ){ 
      $result->{authnx} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::AuthorizationException') ){ 
      $result->{authzx} = $@;
    }
    $output->writeMessageBegin('login', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_set_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_set_keyspace_result();
    eval {
      $self->{handler}->set_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('set_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_result();
    eval {
      $result->{success} = $self->{handler}->get($args->key, $args->column_path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_slice_result();
    eval {
      $result->{success} = $self->{handler}->get_slice($args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_slice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_count_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_count_result();
    eval {
      $result->{success} = $self->{handler}->get_count($args->key, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_count', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_multiget_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_multiget_slice_result();
    eval {
      $result->{success} = $self->{handler}->multiget_slice($args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('multiget_slice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_multiget_count {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_multiget_count_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_multiget_count_result();
    eval {
      $result->{success} = $self->{handler}->multiget_count($args->keys, $args->column_parent, $args->predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('multiget_count', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_range_slices {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_range_slices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_range_slices_result();
    eval {
      $result->{success} = $self->{handler}->get_range_slices($args->column_parent, $args->predicate, $args->range, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_range_slices', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_paged_slice {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_paged_slice_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_paged_slice_result();
    eval {
      $result->{success} = $self->{handler}->get_paged_slice($args->column_family, $args->range, $args->start_column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_paged_slice', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_indexed_slices {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_get_indexed_slices_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_get_indexed_slices_result();
    eval {
      $result->{success} = $self->{handler}->get_indexed_slices($args->column_parent, $args->index_clause, $args->column_predicate, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('get_indexed_slices', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_insert {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_insert_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_insert_result();
    eval {
      $self->{handler}->insert($args->key, $args->column_parent, $args->column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('insert', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_add_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_add_result();
    eval {
      $self->{handler}->add($args->key, $args->column_parent, $args->column, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('add', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_remove_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_remove_result();
    eval {
      $self->{handler}->remove($args->key, $args->column_path, $args->timestamp, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('remove', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove_counter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_remove_counter_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_remove_counter_result();
    eval {
      $self->{handler}->remove_counter($args->key, $args->path, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('remove_counter', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_batch_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_batch_mutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_batch_mutate_result();
    eval {
      $self->{handler}->batch_mutate($args->mutation_map, $args->consistency_level);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('batch_mutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_truncate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_truncate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_truncate_result();
    eval {
      $self->{handler}->truncate($args->cfname);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
    }
    $output->writeMessageBegin('truncate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_schema_versions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_schema_versions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_schema_versions_result();
    eval {
      $result->{success} = $self->{handler}->describe_schema_versions();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_schema_versions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspaces {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_keyspaces_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_keyspaces_result();
    eval {
      $result->{success} = $self->{handler}->describe_keyspaces();
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_keyspaces', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_cluster_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_cluster_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_cluster_name_result();
    $result->{success} = $self->{handler}->describe_cluster_name();
    $output->writeMessageBegin('describe_cluster_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_version {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_version_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_version_result();
    $result->{success} = $self->{handler}->describe_version();
    $output->writeMessageBegin('describe_version', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_ring {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_ring_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_ring_result();
    eval {
      $result->{success} = $self->{handler}->describe_ring($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_ring', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_partitioner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_partitioner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_partitioner_result();
    $result->{success} = $self->{handler}->describe_partitioner();
    $output->writeMessageBegin('describe_partitioner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_snitch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_snitch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_snitch_result();
    $result->{success} = $self->{handler}->describe_snitch();
    $output->writeMessageBegin('describe_snitch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->describe_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::NotFoundException') ){ 
      $result->{nfe} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe_splits {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_describe_splits_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_describe_splits_result();
    eval {
      $result->{success} = $self->{handler}->describe_splits($args->cfName, $args->start_token, $args->end_token, $args->keys_per_split);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('describe_splits', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_add_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_add_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_add_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_add_column_family($args->cf_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_add_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_drop_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_drop_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_drop_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_drop_column_family($args->column_family);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_drop_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_add_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_add_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_add_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_add_keyspace($args->ks_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_add_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_drop_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_drop_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_drop_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_drop_keyspace($args->keyspace);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_drop_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_update_keyspace {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_update_keyspace_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_update_keyspace_result();
    eval {
      $result->{success} = $self->{handler}->system_update_keyspace($args->ks_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_update_keyspace', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_system_update_column_family {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_system_update_column_family_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_system_update_column_family_result();
    eval {
      $result->{success} = $self->{handler}->system_update_column_family($args->cf_def);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('system_update_column_family', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_execute_cql_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_execute_cql_query_result();
    eval {
      $result->{success} = $self->{handler}->execute_cql_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('execute_cql_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_prepare_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_prepare_cql_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_prepare_cql_query_result();
    eval {
      $result->{success} = $self->{handler}->prepare_cql_query($args->query, $args->compression);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('prepare_cql_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_execute_prepared_cql_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_execute_prepared_cql_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_execute_prepared_cql_query_result();
    eval {
      $result->{success} = $self->{handler}->execute_prepared_cql_query($args->itemId, $args->values);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::UnavailableException') ){ 
      $result->{ue} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::TimedOutException') ){ 
      $result->{te} = $@;
        }; if( UNIVERSAL::isa($@,'Cassandra::SchemaDisagreementException') ){ 
      $result->{sde} = $@;
    }
    $output->writeMessageBegin('execute_prepared_cql_query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_set_cql_version {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Cassandra::Cassandra_set_cql_version_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Cassandra::Cassandra_set_cql_version_result();
    eval {
      $self->{handler}->set_cql_version($args->version);
    }; if( UNIVERSAL::isa($@,'Cassandra::InvalidRequestException') ){ 
      $result->{ire} = $@;
    }
    $output->writeMessageBegin('set_cql_version', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
